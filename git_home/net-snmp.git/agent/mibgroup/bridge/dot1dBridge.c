/*
 * Note: this file originally auto-generated by mib2c using
 * : mib2c.iterate.conf,v 5.9 2003/06/04 00:14:41 hardaker Exp $
 */
/*
* reserved by Deltanetwork  2004.12.25 sophie.chen DNI
* modules for dot1dbridge
*/

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "dot1dBridge.h"

/* 
   sophie defined local var only for test
   Maybe we can call low level dev variabel here 
*/

static int value;
static int portindex;
//static int portId;
#define DOT1D_MAX_PACKET_SIZE    1518


/**
  Initialize the dot1dBasePortTable table by defining 
  its contents and how it's structured 
*/

void
initialize_table_dot1dBasePortTable(void)
{
    static oid      dot1dBasePortTable_oid[] =
        { 1, 3, 6, 1, 2, 1, 17, 1, 4 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /** create the table registration information structures */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /** if your table is read only, it's easiest to change the
        HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY */
    my_handler = netsnmp_create_handler_registration("dot1dBasePortTable",
                                                     dot1dBasePortTable_handler,
                                                     dot1dBasePortTable_oid,
                                                     OID_LENGTH
                                                     (dot1dBasePortTable_oid),
                                                     HANDLER_CAN_RONLY);

    if (!my_handler || !table_info || !iinfo) {
        snmp_log(LOG_ERR,
                 "malloc failed in initialize_table_dot1dBasePortTable");
        return;                 /* Serious error. */
    }

/***************************************************
** Setting up the table's definition
****************************************************/

    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: dot1dBasePort */
                                     0);

    /** Define the minimum and maximum accessible columns.  This
        optimizes retrival. */
    table_info->min_column = 1;
    table_info->max_column = 5;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point = dot1dBasePortTable_get_first_data_point;
    iinfo->get_next_data_point = dot1dBasePortTable_get_next_data_point;

    /** you may wish to set these as well */
#ifdef MAYBE_USE_THESE
    iinfo->make_data_context = dot1dBasePortTable_context_convert_function;
    iinfo->free_data_context = dot1dBasePortTable_data_free;

    /** pick *only* one of these if you use them */
    iinfo->free_loop_context = dot1dBasePortTable_loop_free;
    iinfo->free_loop_context_at_end = dot1dBasePortTable_loop_free;
#endif

    /** tie the two structures together */
    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_dot1dBasePortTable",
                "Registering table dot1dBasePortTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}


/** Initializes the dot1dBase module */
void
init_dot1dBase(void)
{
    static oid      dot1dBaseBridgeAddress_oid[] =
        { 1, 3, 6, 1, 2, 1, 17, 1, 1, 0 };
    static oid      dot1dBaseNumPorts_oid[] =
        { 1, 3, 6, 1, 2, 1, 17, 1, 2, 0 };
    static oid      dot1dBaseType_oid[] =
        { 1, 3, 6, 1, 2, 1, 17, 1, 3, 0 };

    DEBUGMSGTL(("dot1dBase", "Initializing\n"));

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dot1dBaseBridgeAddress",
                                         get_dot1dBaseBridgeAddress,
                                         dot1dBaseBridgeAddress_oid,
                                         OID_LENGTH
                                         (dot1dBaseBridgeAddress_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dot1dBaseNumPorts",
                                         get_dot1dBaseNumPorts,
                                         dot1dBaseNumPorts_oid,
                                         OID_LENGTH(dot1dBaseNumPorts_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dot1dBaseType",
                                         get_dot1dBaseType,
                                         dot1dBaseType_oid,
                                         OID_LENGTH(dot1dBaseType_oid),
                                         HANDLER_CAN_RONLY));

    /*
     * here we initialize all the tables we're planning on supporting 
     */
    initialize_table_dot1dBasePortTable();
}


int
get_dot1dBaseBridgeAddress(netsnmp_mib_handler *handler,
                           netsnmp_handler_registration *reginfo,
                           netsnmp_agent_request_info *reqinfo,
                           netsnmp_request_info *requests)
{
    static unsigned char  mac[8];

    switch (reqinfo->mode) {

    case MODE_GET:

        strcpy(mac,"00:a1:E2:a8:a1");
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)mac, 6);
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dot1dBaseNumPorts(netsnmp_mib_handler *handler,
                      netsnmp_handler_registration *reginfo,
                      netsnmp_agent_request_info *reqinfo,
                      netsnmp_request_info *requests)
{
    (void)handler;
    (void)reginfo;
 static int myportcount;
    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&myportcount,
                                 sizeof(int));
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dot1dBaseType(netsnmp_mib_handler *handler,
                  netsnmp_handler_registration *reginfo,
                  netsnmp_agent_request_info *reqinfo,
                  netsnmp_request_info *requests)
{
    static int dot1dBaseType;

    (void)handler;
    (void)reginfo;

    switch (reqinfo->mode) {

    case MODE_GET:

        dot1dBaseType = 8;

        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&dot1dBaseType,
                                 sizeof(int));
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/***************************************************************************************
*now finished base port tables and oid operation 2004.12.23
***************************************************************************************/

/** Initializes the dot1dTp module */
void
init_dot1dTp(void)
{
    static oid      dot1dTpLearnedEntryDiscards_oid[] =
        { 1, 3, 6, 1, 2, 1, 17, 4, 1, 0 };
    static oid      dot1dTpAgingTime_oid[] =
        { 1, 3, 6, 1, 2, 1, 17, 4, 2, 0 };

    DEBUGMSGTL(("dot1dTp", "Initializing\n"));

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dot1dTpLearnedEntryDiscards",
                                         get_dot1dTpLearnedEntryDiscards,
                                         dot1dTpLearnedEntryDiscards_oid,
                                         OID_LENGTH
                                         (dot1dTpLearnedEntryDiscards_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("dot1dTpAgingTime",
                               do_dot1dTpAgingTime,
                               dot1dTpAgingTime_oid,
                               OID_LENGTH(dot1dTpAgingTime_oid),
                               HANDLER_CAN_RWRITE));

    /*
     * here we initialize all the tables we're planning on supporting 
     */
//  initialize_table_dot1dTpFdbTable();  to be continue 2004.12.24
    initialize_table_dot1dTpPortTable();
}


 /** Initialize the dot1dTpPortTable table by defining its contents and how it's structured */
void
initialize_table_dot1dTpPortTable(void)
{
    static oid      dot1dTpPortTable_oid[] =
        { 1, 3, 6, 1, 2, 1, 17, 4, 4 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /** create the table registration information structures */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /** if your table is read only, it's easiest to change the
        HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY */
    my_handler = netsnmp_create_handler_registration("dot1dTpPortTable",
                                                     dot1dTpPortTable_handler,
                                                     dot1dTpPortTable_oid,
                                                     OID_LENGTH
                                                     (dot1dTpPortTable_oid),
                                                     HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info || !iinfo) {
        snmp_log(LOG_ERR,
                 "malloc failed in initialize_table_dot1dTpPortTable");
        return;                 /* Serious error. */
    }

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: dot1dTpPort */
                                     0);

    /** Define the minimum and maximum accessible columns.  This
        optimizes retrival. */
    table_info->min_column = 1;
    table_info->max_column = 5;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point = dot1dTpPortTable_get_first_data_point;
    iinfo->get_next_data_point = dot1dTpPortTable_get_next_data_point;

    /** you may wish to set these as well */
#ifdef MAYBE_USE_THESE
    iinfo->make_data_context = dot1dTpPortTable_context_convert_function;
    iinfo->free_data_context = dot1dTpPortTable_data_free;

    /** pick *only* one of these if you use them */
    iinfo->free_loop_context = dot1dTpPortTable_loop_free;
    iinfo->free_loop_context_at_end = dot1dTpPortTable_loop_free;
#endif

    /** tie the two structures together */
    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_dot1dTpPortTable",
                "Registering table dot1dTpPortTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}


int
get_dot1dTpLearnedEntryDiscards(netsnmp_mib_handler *handler,
                                netsnmp_handler_registration *reginfo,
                                netsnmp_agent_request_info *reqinfo,
                                netsnmp_request_info *requests)
{
    (void)handler;
    (void)reginfo;

    switch (reqinfo->mode) {

    case MODE_GET:

        value = 0;
        snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
                                 (u_char *) &value, sizeof(int));
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_dot1dTpAgingTime(netsnmp_mib_handler *handler,
                    netsnmp_handler_registration *reginfo,
                    netsnmp_agent_request_info *reqinfo,
                    netsnmp_request_info *requests)
{
    (void)handler;
    (void)reginfo;

    switch (reqinfo->mode) {

    case MODE_GET:

	
         /* here get time */
/* 	for example 
        if (AM_Get(AM_GROUP_STA, AM_STA_ELEM_BRIDGE_AGING, NULL,
                &value, AM_DONT_WAIT) != AM_ERROR_NONE)
        {
            return SNMP_ERR_GENERR;
        }
*/
		/* for test I give the init value */
		 value=2;
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *) &value, sizeof(int));
        break;

        /*
         * SET REQUEST
         */
    case MODE_SET_RESERVE1:
        if (*requests->requestvb->val.integer <0  ||
            *requests->requestvb->val.integer >100 )  /* here I only give the range 0--100 we must give micro define */
        {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_WRONGVALUE);
        }
        break;

    case MODE_SET_RESERVE2:
    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        /*
         * perform the value change here 
         */
         /* set action  */
	/* for example  */
/*
        if (AM_Set(AM_GROUP_STA, AM_STA_ELEM_BRIDGE_AGING, NULL,
                  requests->requestvb->val.integer, AM_WAIT) != AM_ERROR_NONE)
        {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_GENERR);
        }
*/
        break;

    case MODE_SET_COMMIT:
    case MODE_SET_UNDO:
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


/*get first index */

netsnmp_variable_list *
dot1dTpPortTable_get_first_data_point(void **my_loop_context,
                                      void **my_data_context,
                                      netsnmp_variable_list *
                                      put_index_data,
                                      netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;

    (void) mydata;

    portindex = 1;
    *my_loop_context = &portindex;
    *my_data_context = &portindex;

    vptr = put_index_data;

    snmp_set_var_value(vptr, (u_char *) &portindex, sizeof(uint));

    return put_index_data;
}

/* get next operation */

netsnmp_variable_list *
dot1dTpPortTable_get_next_data_point(void **my_loop_context,
                                     void **my_data_context,
                                     netsnmp_variable_list *
                                     put_index_data,
                                     netsnmp_iterator_info *mydata)
{
    int *localPortIndex = ( int *) (*my_loop_context);
    netsnmp_variable_list *vptr;

    (void) mydata;

    portindex = *localPortIndex;
    portindex++;

    *my_loop_context = &portindex;
    *my_data_context = &portindex;

    if ((portindex> 16) ||(portindex <0 )) return NULL;

    vptr = put_index_data;

    snmp_set_var_value(vptr, (u_char *) &portindex, sizeof(uint));

    return put_index_data;
}

/** handles requests for the dot1dTpPortTable table, if anything else needs to be done */
int
dot1dTpPortTable_handler(netsnmp_mib_handler *handler,
                         netsnmp_handler_registration *reginfo,
                         netsnmp_agent_request_info *reqinfo,
                         netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
    unsigned  int  *localPortIndex = NULL;
    unsigned int  portId;
    int temp1, temp2;

    (void)handler;
    (void)reginfo;

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed. 
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the dot1dTpPortTable table in question 
         */
        localPortIndex = (unsigned int *)netsnmp_extract_iterator_context(request);
        if (localPortIndex == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            /*
             * XXX: no row existed, if you support creation and this is a
             * set, start dealing with it here, else continue 
             */
        }

        /*
         * extracts the information about the table from the request 
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested 
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request 
         */
        if (table_info == NULL) {
            continue;
        }

        portId = var->name[var->name_length - 1] - 1;

        if ((portId >16) ||(portId <0))
        {
            netsnmp_set_request_error(reqinfo, request,
                                  SNMP_ERR_WRONGVALUE);
            continue;
        }

        switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here 
             */
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_DOT1DTPPORT:

                value = portId + 1;

                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &value, sizeof(int));
                break;

            case COLUMN_DOT1DTPPORTMAXINFO:

                value = DOT1D_MAX_PACKET_SIZE;

                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &value, sizeof(int));
                break;

            case COLUMN_DOT1DTPPORTINFRAMES:
		
                value = temp1 + temp2;

                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *) &value, sizeof(int));
                break;

            case COLUMN_DOT1DTPPORTOUTFRAMES:

                value = temp1 + temp2;

                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *) &value, sizeof(int));
                break;

            case COLUMN_DOT1DTPPORTINDISCARDS:

 			/* here get system value */
			/* support value =5 */
 			value =5;
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *) &value, sizeof(int));
                break;

            default:
                /*
                 * We shouldn't get here 
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in dot1dTpPortTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
            /*
             * set handling... 
             */

        default:
            snmp_log(LOG_ERR,
                     "problem encountered in dot1dTpPortTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}


/** Initialize the dot1dStaticTable table by defining its contents and how it's structured */
void
initialize_table_dot1dStaticTable(void)
{
    static oid      dot1dStaticTable_oid[] =
        { 1, 3, 6, 1, 2, 1, 17, 5, 1 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /** create the table registration information structures */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /** if your table is read only, it's easiest to change the
        HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY */
    my_handler = netsnmp_create_handler_registration("dot1dStaticTable",
                                                     dot1dStaticTable_handler,
                                                     dot1dStaticTable_oid,
                                                     OID_LENGTH
                                                     (dot1dStaticTable_oid),
                                                     HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info || !iinfo) {
        snmp_log(LOG_ERR,
                 "malloc failed in initialize_table_dot1dStaticTable");
        return;                 /* Serious error. */
    }

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_OCTET_STR, /* index: dot1dStaticAddress */
                                     ASN_INTEGER,       /* index: dot1dStaticReceivePort */
                                     0);

    /** Define the minimum and maximum accessible columns.  This
        optimizes retrival. */
    table_info->min_column = 1;
    table_info->max_column = 4;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point = dot1dStaticTable_get_first_data_point;
    iinfo->get_next_data_point = dot1dStaticTable_get_next_data_point;

    /** you may wish to set these as well */
#ifdef MAYBE_USE_THESE
    iinfo->make_data_context = dot1dStaticTable_context_convert_function;
    iinfo->free_data_context = dot1dStaticTable_data_free;

    /** pick *only* one of these if you use them */
    iinfo->free_loop_context = dot1dStaticTable_loop_free;
    iinfo->free_loop_context_at_end = dot1dStaticTable_loop_free;
#endif

    /** tie the two structures together */
    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_dot1dStaticTable",
                "Registering table dot1dStaticTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}



netsnmp_variable_list *
dot1dStpPortTable_get_first_data_point(void **my_loop_context,
                                       void **my_data_context,
                                       netsnmp_variable_list *
                                       put_index_data,
                                       netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;

//    *my_loop_context = /** XXX */ ;
//    *my_data_context = /** XXX */ ;

//    vptr = put_index_data;

//    snmp_set_var_value(vptr, (u_char *) /** XXX: dot1dStpPort data */ ,
//                       /** XXX: length of dot1dStpPort data */ );
//    vptr = vptr->next_variable;

//    return put_index_data;
	return NULL;
}

/** functionally the same as dot1dStpPortTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it to your local data type and
   then return my_loop_context->next.  The my_data_context pointer
   should be set to something you need later (in your main
   dot1dStpPortTable_handler routine) and the indexes in put_index_data updated
   again. */
netsnmp_variable_list *
dot1dStpPortTable_get_next_data_point(void **my_loop_context,
                                      void **my_data_context,
                                      netsnmp_variable_list *
                                      put_index_data,
                                      netsnmp_iterator_info *mydata)
{

//    netsnmp_variable_list *vptr;

//    *my_loop_context = /** XXX */ ;
//    *my_data_context = /** XXX */ ;

//    vptr = put_index_data;

//    snmp_set_var_value(vptr, (u_char *) /** XXX: dot1dStpPort data */ ,
//                       /** XXX: length of dot1dStpPort data */ );
//    vptr = vptr->next_variable;

    return put_index_data;
}

/** handles requests for the dot1dStpPortTable table, if anything else needs to be done */
int
dot1dStpPortTable_handler(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{

//    netsnmp_request_info *request;
//    netsnmp_table_request_info *table_info;
//    netsnmp_variable_list *var;

//    for (request = requests; request; request = request->next) {
//        var = request->requestvb;
//        if (request->processed != 0)
//            continue;

        /** perform anything here that you need to do before each
           request is processed. */

        /** the following extracts the my_data_context pointer set in
           the loop functions above.  You can then use the results to
           help return data for the columns of the dot1dStpPortTable table in question */
//        /** XXX */  =
//            ( /** XXX */ *)netsnmp_extract_iterator_context(request);
//        if ( /** XXX */  == NULL) {
//            if (reqinfo->mode == MODE_GET) {
//                netsnmp_set_request_error(reqinfo, request,
//                                          SNMP_NOSUCHINSTANCE);
//                continue;
//            }
            /** XXX: no row existed, if you support creation and this is a
               set, start dealing with it here, else continue */
//        }

        /** extracts the information about the table from the request */
//        table_info = netsnmp_extract_table_info(request);
        /** table_info->colnum contains the column number requested */
        /** table_info->indexes contains a linked list of snmp variable
           bindings for the indexes of the table.  Values in the list
           have been set corresponding to the indexes of the
           request */
//        if (table_info == NULL) {
//            continue;
//        }

//        switch (reqinfo->mode) {
            /** the table_iterator helper should change all GETNEXTs
               into GETs for you automatically, so you don't have to
               worry about the GETNEXT case.  Only GETs and SETs need
               to be dealt with here */
//        case MODE_GET:
//            switch (table_info->colnum) {
///            case COLUMN_DOT1DSTPPORT:
//                snmp_set_var_typed_value(var, ASN_INTEGER,
//                                         (u_char *) /** XXX: column data */
//                                         , /** XXX: column data length */
//                                         );
//                break;

//            case COLUMN_DOT1DSTPPORTPRIORITY:
//                snmp_set_var_typed_value(var, ASN_INTEGER,
//                                         (u_char *) /** XXX: column data */
//                                         , /** XXX: column data length */
//                                         );
//                break;

//            case COLUMN_DOT1DSTPPORTSTATE:
//                snmp_set_var_typed_value(var, ASN_INTEGER,
//                                         (u_char *) /** XXX: column data */
//                                         , /** XXX: column data length */
//                                         );
//                break;

//            case COLUMN_DOT1DSTPPORTENABLE:
//                snmp_set_var_typed_value(var, ASN_INTEGER,
//                                         (u_char *) /** XXX: column data */
//                                         , /** XXX: column data length */
//                                         );
//                break;
//
//            case COLUMN_DOT1DSTPPORTPATHCOST:
//                snmp_set_var_typed_value(var, ASN_INTEGER,
//                                         (u_char *) /** XXX: column data */
//                                         , /** XXX: column data length */
//                                         );
//                break;
//
//            case COLUMN_DOT1DSTPPORTDESIGNATEDROOT:
//                snmp_set_var_typed_value(var, ASN_OCTET_STR,
//                                         (u_char *) /** XXX: column data */
//                                         , /** XXX: column data length */
//                                         );
//                break;

//            case COLUMN_DOT1DSTPPORTDESIGNATEDCOST:
//                snmp_set_var_typed_value(var, ASN_INTEGER,
//                                         (u_char *) /** XXX: column data */
//                                         , /** XXX: column data length */
//                                         );
//                break;

//            case COLUMN_DOT1DSTPPORTDESIGNATEDBRIDGE:
//                snmp_set_var_typed_value(var, ASN_OCTET_STR,
//                                         (u_char *) /** XXX: column data */
//                                         , /** XXX: column data length */
//                                         );
//                break;

//            case COLUMN_DOT1DSTPPORTDESIGNATEDPORT:
//                snmp_set_var_typed_value(var, ASN_OCTET_STR,
//                                         (u_char *) /** XXX: column data */
//                                         , /** XXX: column data length */
//                                         );
//                break;

//            case COLUMN_DOT1DSTPPORTFORWARDTRANSITIONS:
//                snmp_set_var_typed_value(var, ASN_COUNTER,
//                                         (u_char *) /** XXX: column data */
//                                         , /** XXX: column data length */
//                                         );
//                break;

//            case COLUMN_DOT1DSTPPORTPATHCOST32:
//                snmp_set_var_typed_value(var, ASN_INTEGER,
//                                         (u_char *) /** XXX: column data */
//                                         , /** XXX: column data length */
//                                         );
//                break;

//            default:
//                        /** We shouldn't get here */
//                snmp_log(LOG_ERR,
//                         "problem encountered in dot1dStpPortTable_handler: unknown column\n");
//            }
//            break;

//        case MODE_SET_RESERVE1:
                /** set handling... */

//        default:
//            snmp_log(LOG_ERR,
//                     "problem encountered in dot1dStpPortTable_handler: unsupported mode\n");
//        }
//    }
    return SNMP_ERR_NOERROR;
}

/** returns the first data point within the dot1dTpFdbTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later (in your main dot1dTpFdbTable_handler routine) that will provide
    you with the data to return in a given row.  This could be the
    same pointer as what my_loop_context is set to, or something
    different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
dot1dTpFdbTable_get_first_data_point(void **my_loop_context,
                                     void **my_data_context,
                                     netsnmp_variable_list *
                                     put_index_data,
                                     netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;

//    *my_loop_context = /** XXX */ ;
//    *my_data_context = /** XXX */ ;

    vptr = put_index_data;

//    snmp_set_var_value(vptr,
//                       (u_char *) /** XXX: dot1dTpFdbAddress data */ ,
//                       /** XXX: length of dot1dTpFdbAddress data */ );
    vptr = vptr->next_variable;

    return put_index_data;
}

/** functionally the same as dot1dTpFdbTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it to your local data type and
   then return my_loop_context->next.  The my_data_context pointer
   should be set to something you need later (in your main
   dot1dTpFdbTable_handler routine) and the indexes in put_index_data updated
   again. */
netsnmp_variable_list *
dot1dTpFdbTable_get_next_data_point(void **my_loop_context,
                                    void **my_data_context,
                                    netsnmp_variable_list * put_index_data,
                                    netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;

//    *my_loop_context = /** XXX */ ;
//    *my_data_context = /** XXX */ ;

    vptr = put_index_data;

//    snmp_set_var_value(vptr,
///                       (u_char *) /** XXX: dot1dTpFdbAddress data */ ,
//                       /** XXX: length of dot1dTpFdbAddress data */ );
    vptr = vptr->next_variable;

    return put_index_data;
}

/** handles requests for the dot1dTpFdbTable table, if anything else needs to be done */
int
dot1dTpFdbTable_handler(netsnmp_mib_handler *handler,
                        netsnmp_handler_registration *reginfo,
                        netsnmp_agent_request_info *reqinfo,
                        netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /** perform anything here that you need to do before each
           request is processed. */

        /** the following extracts the my_data_context pointer set in
           the loop functions above.  You can then use the results to
           help return data for the columns of the dot1dTpFdbTable table in question */
//        /** XXX */  =
//            ( /** XXX */ *)netsnmp_extract_iterator_context(request);
//        if ( /** XXX */  == NULL) {
//            if (reqinfo->mode == MODE_GET) {
//                netsnmp_set_request_error(reqinfo, request,
//                                          SNMP_NOSUCHINSTANCE);
//                continue;
//            }
            /** XXX: no row existed, if you support creation and this is a
               set, start dealing with it here, else continue */
        }

        /** extracts the information about the table from the request */
        table_info = netsnmp_extract_table_info(request);
        /** table_info->colnum contains the column number requested */
        /** table_info->indexes contains a linked list of snmp variable
           bindings for the indexes of the table.  Values in the list
           have been set corresponding to the indexes of the
           request */
//        if (table_info == NULL) {
//            continue;
//        }

        switch (reqinfo->mode) {
            /** the table_iterator helper should change all GETNEXTs
               into GETs for you automatically, so you don't have to
               worry about the GETNEXT case.  Only GETs and SETs need
               to be dealt with here */
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_DOT1DTPFDBADDRESS:
//                snmp_set_var_typed_value(var, ASN_OCTET_STR,
//                                         (u_char *) /** XXX: column data */
//                                         , /** XXX: column data length */
//                                       );
                break;

            case COLUMN_DOT1DTPFDBPORT:
//              snmp_set_var_typed_value(var, ASN_INTEGER,
//                                       (u_char *) /** XXX: column data */
//                                       , /** XXX: column data length */
//                                       );
                break;

          case COLUMN_DOT1DTPFDBSTATUS:
//              snmp_set_var_typed_value(var, ASN_INTEGER,
//                                       (u_char *) /** XXX: column data */
//                                       , /** XXX: column data length */
//                                       );
              break;

            default:
                        /** We shouldn't get here */
                snmp_log(LOG_ERR,
                         "problem encountered in dot1dTpFdbTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
                /** set handling... */

        default:
            snmp_log(LOG_ERR,
                     "problem encountered in dot1dTpFdbTable_handler: unsupported mode\n");
        }
    
    return SNMP_ERR_NOERROR;
}

/** returns the first data point within the dot1dBasePortTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later (in your main dot1dBasePortTable_handler routine) that will provide
    you with the data to return in a given row.  This could be the
    same pointer as what my_loop_context is set to, or something
    different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
dot1dBasePortTable_get_first_data_point(void **my_loop_context,
                                        void **my_data_context,
                                        netsnmp_variable_list *
                                        put_index_data,
                                        netsnmp_iterator_info *mydata)
{

    	netsnmp_variable_list *vptr;
    	portindex=1;
  	*my_loop_context = &portindex;
 	*my_data_context =&portindex;

    	vptr = put_index_data;
    	snmp_set_var_value(vptr, (u_char *)&portindex,sizeof(int));
    	return put_index_data;
}

/** functionally the same as dot1dBasePortTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it to your local data type and
   then return my_loop_context->next.  The my_data_context pointer
   should be set to something you need later (in your main
   dot1dBasePortTable_handler routine) and the indexes in put_index_data updated
   again. */
netsnmp_variable_list *
dot1dBasePortTable_get_next_data_point(void **my_loop_context,
                                       void **my_data_context,
                                       netsnmp_variable_list *
                                       put_index_data,
                                       netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;
    int *localPortIndex = (int *) (*my_loop_context);
    portindex = *localPortIndex;
    portindex++;
		
  *my_loop_context = &portindex;
  *my_data_context =&portindex;
  if((portindex >16) || (portindex <0 )) return NULL;
    vptr = put_index_data;
    snmp_set_var_value(vptr, (u_char *)&portindex,sizeof(int));
    return put_index_data;
}


/** handles requests for the dot1dBasePortTable table, if anything else needs to be done */
int
dot1dBasePortTable_handler(netsnmp_mib_handler *handler,
                           netsnmp_handler_registration *reginfo,
                           netsnmp_agent_request_info *reqinfo,
                           netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
    int *localPortIndex = NULL;
    static unsigned long  ifIndex;
    static int portCircuit[] = {0, 0};
    static int value;
	
    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed. 
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the dot1dBasePortTable table in question 
         */
        localPortIndex = (int *)netsnmp_extract_iterator_context(request);
        if (localPortIndex == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            /*
             * XXX: no row existed, if you support creation and this is a
             * set, start dealing with it here, else continue 
             */
        }

        /*
         * extracts the information about the table from the request 
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested 
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request 
         */
        if (table_info == NULL) {
            continue;
        }

        ifIndex = var->name[var->name_length - 1];

        if (ifIndex > 16)
        {
            netsnmp_set_request_error(reqinfo, request,
                                  SNMP_NOSUCHINSTANCE);
            continue;
        }

        switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here 
             */
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_DOT1DBASEPORT:

                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &ifIndex, sizeof(unsigned long));
                break;

            case COLUMN_DOT1DBASEPORTIFINDEX:

                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &ifIndex, sizeof(unsigned long));
                break;

            case COLUMN_DOT1DBASEPORTCIRCUIT:

                snmp_set_var_typed_value(var, ASN_OBJECT_ID,
                                         (u_char *) portCircuit,
                                         2 * sizeof(int));
                break;

            case COLUMN_DOT1DBASEPORTDELAYEXCEEDEDDISCARDS:

      //         value = RSTP_GetBasePortDelayExceededDiscards(ifIndex - 1);

     //           snmp_set_var_typed_value(var, ASN_COUNTER,
     //                                   (u_char *) &value, sizeof(int));
                break;

            case COLUMN_DOT1DBASEPORTMTUEXCEEDEDDISCARDS:

          //      value = RSTP_GetBasePortMtuExceededDiscards(ifIndex - 1);

         //       snmp_set_var_typed_value(var, ASN_COUNTER,
           //                              (u_char *) &value, sizeof(int));
                break;

            default:
                /*
                 * We shouldn't get here 
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in dot1dBasePortTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
            /*
             * set handling... 
             */

        default:
            snmp_log(LOG_ERR,
                     "problem encountered in dot1dBasePortTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}
 

 
netsnmp_variable_list *
dot1dStaticTable_get_first_data_point(void **my_loop_context,
                                      void **my_data_context,
                                      netsnmp_variable_list *
                                      put_index_data,
                                      netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;

//    *my_loop_context = /** XXX */ ;
//    *my_data_context = /** XXX */ ;

    vptr = put_index_data;

//    snmp_set_var_value(vptr,
//                       (u_char *) /** XXX: dot1dStaticAddress data */ ,
//                       /** XXX: length of dot1dStaticAddress data */ );
    vptr = vptr->next_variable;
//    snmp_set_var_value(vptr,
//                       (u_char *) /** XXX: dot1dStaticReceivePort data */ ,
//                       /** XXX: length of dot1dStaticReceivePort data */ );
    vptr = vptr->next_variable;

    return put_index_data;
}

/** functionally the same as dot1dStaticTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it to your local data type and
   then return my_loop_context->next.  The my_data_context pointer
   should be set to something you need later (in your main
   dot1dStaticTable_handler routine) and the indexes in put_index_data updated
   again. */
netsnmp_variable_list *
dot1dStaticTable_get_next_data_point(void **my_loop_context,
                                     void **my_data_context,
                                     netsnmp_variable_list *
                                     put_index_data,
                                     netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;

//    *my_loop_context = /** XXX */ ;
//    *my_data_context = /** XXX */ ;

    vptr = put_index_data;

//    snmp_set_var_value(vptr,
///                    (u_char *) /** XXX: dot1dStaticAddress data */ ,
//                       /** XXX: length of dot1dStaticAddress data */ );
    vptr = vptr->next_variable;
//    snmp_set_var_value(vptr,
//                       (u_char *) /** XXX: dot1dStaticReceivePort data */ ,
//                       /** XXX: length of dot1dStaticReceivePort data */ );
    vptr = vptr->next_variable;

    return put_index_data;
}

/** handles requests for the dot1dStaticTable table, if anything else needs to be done */
int
dot1dStaticTable_handler(netsnmp_mib_handler *handler,
                         netsnmp_handler_registration *reginfo,
                         netsnmp_agent_request_info *reqinfo,
                         netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /** perform anything here that you need to do before each
           request is processed. */

        /** the following extracts the my_data_context pointer set in
           the loop functions above.  You can then use the results to
           help return data for the columns of the dot1dStaticTable table in question */
//        /** XXX */  =
//            ( /** XXX */ *)netsnmp_extract_iterator_context(request);
//        if ( /** XXX */  == NULL) {
//            if (reqinfo->mode == MODE_GET) {
//                netsnmp_set_request_error(reqinfo, request,
//                                          SNMP_NOSUCHINSTANCE);
//                continue;
//            }
            /** XXX: no row existed, if you support creation and this is a
               set, start dealing with it here, else continue */
        }

        /** extracts the information about the table from the request */
        table_info = netsnmp_extract_table_info(request);
        /** table_info->colnum contains the column number requested */
        /** table_info->indexes contains a linked list of snmp variable
           bindings for the indexes of the table.  Values in the list
           have been set corresponding to the indexes of the
           request */
//        if (table_info == NULL) {
//            continue;
//        }

        switch (reqinfo->mode) {
            /** the table_iterator helper should change all GETNEXTs
               into GETs for you automatically, so you don't have to
               worry about the GETNEXT case.  Only GETs and SETs need
               to be dealt with here */
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_DOT1DSTATICADDRESS:
//                snmp_set_var_typed_value(var, ASN_OCTET_STR,
//                                         (u_char *) /** XXX: column data */
//                                         , /** XXX: column data length */
//                                         );
                break;

            case COLUMN_DOT1DSTATICRECEIVEPORT:
//                snmp_set_var_typed_value(var, ASN_INTEGER,
//                                         (u_char *) /** XXX: column data */
//                                         , /** XXX: column data length */
//                                         );
                break;

            case COLUMN_DOT1DSTATICALLOWEDTOGOTO:
//                snmp_set_var_typed_value(var, ASN_OCTET_STR,
//                                         (u_char *) /** XXX: column data */
//                                         , /** XXX: column data length */
//                                         );
                break;

            case COLUMN_DOT1DSTATICSTATUS:
//                snmp_set_var_typed_value(var, ASN_INTEGER,
//                                         (u_char *) /** XXX: column data */
//                                         , /** XXX: column data length */
//                                         );
                break;

            default:
                        /** We shouldn't get here */
                snmp_log(LOG_ERR,
                         "problem encountered in dot1dStaticTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
                /** set handling... */

        default:
            snmp_log(LOG_ERR,
                     "problem encountered in dot1dStaticTable_handler: unsupported mode\n");
        }
//    }
    return SNMP_ERR_NOERROR;
}


/** Initializes the dot1dBridge module */
void
init_dot1dBridge(void)
{

  /** here we initialize all the tables we're planning on supporting */
  //  initialize_table_dot1dStpPortTable();
//   initialize_table_dot1dTpFdbTable();
 //   initialize_table_dot1dBasePortTable();
  init_dot1dBase();
  init_dot1dTp();
 //   initialize_table_dot1dTpPortTable();
//    initialize_table_dot1dStaticTable();
}



/** Initialize the dot1dTpFdbTable table by defining its contents and how it's structured */
void
initialize_table_dot1dTpFdbTable(void)
{
    static oid      dot1dTpFdbTable_oid[] =
        { 1, 3, 6, 1, 2, 1, 17, 4, 3 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /*
     * create the table structure itself 
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
     */
    my_handler = netsnmp_create_handler_registration("dot1dTpFdbTable",
                                                     dot1dTpFdbTable_handler,
                                                     dot1dTpFdbTable_oid,
                                                     OID_LENGTH
                                                     (dot1dTpFdbTable_oid),
                                                     HANDLER_CAN_RONLY);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_PRIV_IMPLIED_OCTET_STR, /* index: dot1dTpFdbAddress */
                                     0);

    table_info->min_column = 1;
    table_info->max_column = 3;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point = dot1dTpFdbTable_get_first_data_point;
    iinfo->get_next_data_point = dot1dTpFdbTable_get_next_data_point;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_dot1dTpFdbTable",
                "Registering table dot1dTpFdbTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}



/** returns the first data point within the dot1dTpFdbTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
/*
netsnmp_variable_list *
dot1dTpFdbTable_get_first_data_point(void **my_loop_context,
                                     void **my_data_context,
                                     netsnmp_variable_list *
                                     put_index_data,
                                     netsnmp_iterator_info *mydata)
{
    netsnmp_variable_list *vptr;
    ADM_Entry_t fdbEntry;

    (void)mydata;

    memset((uint8 *)&fdbEntry, 0, sizeof(ADM_Entry_t));

    if (DOT1D_GetNextFdbEntry(&fdbEntry)) return NULL;

    memcpy(fdbIndex.mac, fdbEntry.mac, 6);

    *my_loop_context = &fdbIndex;
    *my_data_context = &fdbIndex;

    vptr = put_index_data;

    snmp_set_var_value(vptr, (u_char *) fdbIndex.mac, 6 * sizeof(uint8));

    return put_index_data;
}
*/
/** functionally the same as dot1dTpFdbTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it and the return
   my_loop_context->next.  The my_data_context pointer should be set
   to something you need later and the indexes in put_index_data
   updated again. */
/*
netsnmp_variable_list *
dot1dTpFdbTable_get_next_data_point(void **my_loop_context,
                                    void **my_data_context,
                                    netsnmp_variable_list * put_index_data,
                                    netsnmp_iterator_info *mydata)
{
    DOT1D_FDBTableIndicies_t *fdbPtr = (DOT1D_FDBTableIndicies_t *) (*my_loop_context);
    ADM_Entry_t fdbEntry;
    netsnmp_variable_list *vptr;

    (void)mydata;

    memcpy(fdbEntry.mac, fdbPtr->mac, 6);

    if (DOT1D_GetNextFdbEntry(&fdbEntry)) return NULL;

    memcpy(fdbIndex.mac, fdbEntry.mac, 6);

    *my_loop_context = &fdbIndex;
    *my_data_context = &fdbIndex;

    vptr = put_index_data;

    snmp_set_var_value(vptr, (u_char *) fdbIndex.mac, 6 * sizeof(uint8));

    return put_index_data;
}
*/
/** handles requests for the dot1dTpFdbTable table, if anything else needs to be done */
/*
int
dot1dTpFdbTable_handler(netsnmp_mib_handler *handler,
                        netsnmp_handler_registration *reginfo,
                        netsnmp_agent_request_info *reqinfo,
                        netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
    DOT1D_FDBTableIndicies_t *fdbPtr = NULL;
    ADM_Entry_t fdbEntry;
    CDM_BridgeStaticEntry_t staticEntry;
    static uint8 mac[6];
    int staticAddress = FALSE;
    uint portId = PAL_INVALID_ID;

    (void)handler;
    (void)reginfo;

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;
*/
       /*
         * perform anything here that you need to do before each
         * request is processed. 
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the dot1dTpFdbTable table in question 
         */
/*
        fdbPtr = (DOT1D_FDBTableIndicies_t *)netsnmp_extract_iterator_context(request);
        if (fdbPtr == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
*/
            /*
             * XXX: no row existed, if you support creation and this is a
             * set, start dealing with it here, else continue 
             */
//        }

        /*
         * extracts the information about the table from the request 
         */
//        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested 
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request 
         */
/*
        if (table_info == NULL) {
            continue;
        }

        mac[0] = var->name[var->name_length - 6];
        mac[1] = var->name[var->name_length - 5];
        mac[2] = var->name[var->name_length - 4];
        mac[3] = var->name[var->name_length - 3];
        mac[4] = var->name[var->name_length - 2];
        mac[5] = var->name[var->name_length - 1];

        switch (reqinfo->mode) {

        case MODE_GET:

            staticAddress = FALSE;
            portId = PAL_INVALID_ID;

            if (table_info->colnum == COLUMN_DOT1DTPFDBPORT ||
                table_info->colnum == COLUMN_DOT1DTPFDBSTATUS)
            {
                memcpy(staticEntry.macAddress, mac, 6);
                if (AM_Get(AM_GROUP_BRDG, AM_BRDG_ELEM_GET_ENTRY, 
                         NULL, &staticEntry, AM_DONT_WAIT) == AM_ERROR_NONE)
                {
                    staticAddress = TRUE;
                    portId = staticEntry.destinationPortId;
                }
                else
                {
                    memcpy(fdbEntry.mac, mac, 6);
                    fdbEntry.module = BIOS_PORT_SOURCE_SECURITY_MODULE_NONE;
                    if (ADM_GetMAC(&fdbEntry))
                    {
                        portId = fdbEntry.portId;
                    }
                }
            }

            switch (table_info->colnum) {
            case COLUMN_DOT1DTPFDBADDRESS:

                snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                         (u_char *) mac, 6);
                break;

            case COLUMN_DOT1DTPFDBPORT:

                if (portId == PAL_INVALID_ID)
                {
                    return SNMP_ERR_GENERR;
                }

                value = portId + 1;
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &value, sizeof(int));
                break;

            case COLUMN_DOT1DTPFDBSTATUS:

                if (staticAddress)
                {
                    value = 5;  
                }
                else
                {
                    value = 3; 
                }

                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &value, sizeof(int));
                break;

            default:
                snmp_log(LOG_ERR,
                         "problem encountered in dot1dTpFdbTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
        default:
            snmp_log(LOG_ERR,
                     "problem encountered in dot1dTpFdbTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}
*/
/** returns the first data point within the dot1dTpPortTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/

 
