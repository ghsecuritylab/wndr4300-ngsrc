/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.iterate.conf,v 5.5.2.1 2003/07/02 17:36:07 hardaker Exp $
 */
/*********************************************************
* Modified  by Deltanetwork  2004.12.25 --- DNI  
* modules for dot1dbridge, base net-snmp-5.0.9
*  auto generated by  mib2c code and I  merge it to dot1dbridge
***********************************************************/
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "dot1dBridge_table.h"

#include"stdio.h"
#include"stdlib.h"
#include"unistd.h"
/*****************************************************
* Delta Network----sophie get Macaddress 2005.1.5
* Neither Net-SNMP nor dirver support bridge mib routines,
* After patch linux kernel  with bridge module ,we can call the brctl,
*ioctl to operate CB3000 bridge infor 
 ******************************************************/
#include <net/if.h>
#include <sys/socket.h>
#include <unistd.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <stdio.h>


#define DOT1D_BRIDGEID_SIZE	200 /* I test on pc ,the table will created to 200 */

#define maxPortPriority		2
#define minPortPriority		65535
#define minPortPathCost		0
#define maxPortPathCost		65535
#define MAX_PORT_MUM 2
#define MIN_PORT_NUM 1
#define BRIDGE_IF_NAME	"br0"
#define ASN_OCTET_MAC ((u_char)0xC0 |(u_char)0x04) /* by RFC Mac index length 2005.1.12  */
#define NEEDSTP
#define BRCTL_PATH	"/bin/brctl2"
/* Globol variable  */


/* Forwarding Database table */
static int gfdbcount; 	/* caculate the forwarding database  count */
static ForwardDataBase_T *gfdb_info;


static StpTable_T *gstp_info;


/* TP table info  */	

/* to be continue */

static int value;
static int portno;
static int portindex;
static long  ffdbindex;
static MACINDEX_T macindex;

/** Initialize the dot1dStpPortTable table by defining its contents and how it's structured */


void
initialize_table_dot1dStpPortTable(void)
{
    static oid      dot1dStpPortTable_oid[] =
        { 1, 3, 6, 1, 2, 1, 17, 2, 15 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /*
     * create the table structure itself 
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
     */
    my_handler = netsnmp_create_handler_registration("dot1dStpPortTable",
                                                     dot1dStpPortTable_handler,
                                                     dot1dStpPortTable_oid,
                                                     OID_LENGTH
                                                     (dot1dStpPortTable_oid),
                                                     HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: dot1dStpPort */
                                     0);

    table_info->min_column = 1;
    table_info->max_column = 11;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point = dot1dStpPortTable_get_first_data_point;
    iinfo->get_next_data_point = dot1dStpPortTable_get_next_data_point;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_dot1dStpPortTable",
                "Registering table dot1dStpPortTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}


/* endif NEEDSTP */

/** Initialize the dot1dTpFdbTable table by defining its contents and how it's structured */
void
initialize_table_dot1dTpFdbTable(void)
{
    static oid      dot1dTpFdbTable_oid[] = { 1, 3, 6, 1, 2, 1, 17, 4, 3 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /*
     * create the table structure itself 
     */

	char bname[6];
        memcpy(bname,BRIDGE_IF_NAME,6);
        /* here init the fdb.info that we will use it later */
      if(getfdbinfo(bname)<0)
		printf("init the fdb error");
     
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
     */
    my_handler = netsnmp_create_handler_registration("dot1dTpFdbTable",
                                                     dot1dTpFdbTable_handler,
                                                     dot1dTpFdbTable_oid,
                                                     OID_LENGTH
                                                     (dot1dTpFdbTable_oid),
                                                     HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
     
//    netsnmp_table_helper_add_indexes(table_info,0xC4,0);
    netsnmp_table_helper_add_indexes(table_info,ASN_OCTET_MAC,0);

    table_info->min_column = 1;
    table_info->max_column = 3;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point = dot1dTpFdbTable_get_first_data_point;
    iinfo->get_next_data_point = dot1dTpFdbTable_get_next_data_point;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_dot1dTpFdbTable",
                "Registering table dot1dTpFdbTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}

/** Initialize the dot1dBasePortTable table by defining its contents and how it's structured */

static int gloub_ifIndex[2];
void
initialize_table_dot1dBasePortTable(void)
{
	char ifName[10];
	int ifIndex;
	FILE *fp;
	
	fp=fopen("/proc/net/dev","r");
	if(fp)
	{
		while(fgetc(fp)!='\n');
		for(ifIndex=1;ifIndex<5;++ifIndex)
		{
			while(fgetc(fp)!='\n');
			fscanf(fp,"%4s",ifName);
			if(strcmp(ifName,"ath0")==0)
			{
				gloub_ifIndex[1]=ifIndex;
				continue;
			}
			if(strcmp(ifName,"eth0")==0)
				gloub_ifIndex[0]=ifIndex;
		}
		fclose(fp);
	}
    static oid      dot1dBasePortTable_oid[] =
        { 1, 3, 6, 1, 2, 1, 17, 1, 4 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /*
     * create the table structure itself 
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
     */
    my_handler = netsnmp_create_handler_registration("dot1dBasePortTable",
                                                     dot1dBasePortTable_handler,
                                                     dot1dBasePortTable_oid,
                                                     OID_LENGTH
                                                     (dot1dBasePortTable_oid),
                                                     HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: dot1dBasePort */
                                     0);

    table_info->min_column = 1;
    table_info->max_column = 5;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point = dot1dBasePortTable_get_first_data_point;
    iinfo->get_next_data_point = dot1dBasePortTable_get_next_data_point;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_dot1dBasePortTable",
                "Registering table dot1dBasePortTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}

/** Initialize the dot1dTpPortTable table by defining its contents and how it's structured */
void
initialize_table_dot1dTpPortTable(void)
{
    static oid      dot1dTpPortTable_oid[] =
        { 1, 3, 6, 1, 2, 1, 17, 4, 4 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /*
     * create the table structure itself 
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
     */
    my_handler = netsnmp_create_handler_registration("dot1dTpPortTable",
                                                     dot1dTpPortTable_handler,
                                                     dot1dTpPortTable_oid,
                                                     OID_LENGTH
                                                     (dot1dTpPortTable_oid),
                                                     HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: dot1dTpPort */
                                     0);

    table_info->min_column = 1;
    table_info->max_column = 5;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point = dot1dTpPortTable_get_first_data_point;
    iinfo->get_next_data_point = dot1dTpPortTable_get_next_data_point;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_dot1dTpPortTable",
                "Registering table dot1dTpPortTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}

#ifdef SOPHIENEED

/** Initialize the dot1dStaticTable table by defining its contents and how it's structured */
void
initialize_table_dot1dStaticTable(void)
{
    static oid      dot1dStaticTable_oid[] =
        { 1, 3, 6, 1, 2, 1, 17, 5, 1 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /*
     * create the table structure itself 
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
     */
    my_handler = netsnmp_create_handler_registration("dot1dStaticTable",
                                                     dot1dStaticTable_handler,
                                                     dot1dStaticTable_oid,
                                                     OID_LENGTH
                                                     (dot1dStaticTable_oid),
                                                     HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
   netsnmp_table_helper_add_indexes(table_info, ASN_OCTET_STR, ASN_INTEGER,0);

    table_info->min_column = 1;
    table_info->max_column = 4;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point = dot1dStaticTable_get_first_data_point;
    iinfo->get_next_data_point = dot1dStaticTable_get_next_data_point;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_dot1dStaticTable",
                "Registering table dot1dStaticTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}

#endif /* endif init static table */ 

/** Initializes the dot1dBridge_table module */
void
init_dot1dBridge_table(void)
{

    /*
     * here we initialize all the tables we're planning on supporting 
     */
    initialize_table_dot1dStpPortTable();  
    initialize_table_dot1dTpFdbTable();
    initialize_table_dot1dBasePortTable();
	getstp();
//    initialize_table_dot1dTpPortTable();
 //   initialize_table_dot1dStaticTable();
  /* note : because staticTable there are dynamic and static table so I have not test these */
}


netsnmp_variable_list *
dot1dStpPortTable_get_first_data_point(void **my_loop_context,
                                       void **my_data_context,
                                       netsnmp_variable_list *
                                       put_index_data,
                                       netsnmp_iterator_info *mydata)
{
	getstp();
    netsnmp_variable_list *vptr;
    if(gstp_info==NULL)
		return NULL;
    *my_loop_context =gstp_info;
    *my_data_context =gstp_info;

    vptr = put_index_data;

    snmp_set_var_value(vptr, (u_char *)&gstp_info->stpport,
                        sizeof(int));

    return put_index_data;
}

/** functionally the same as dot1dStpPortTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it and the return
   my_loop_context->next.  The my_data_context pointer should be set
   to something you need later and the indexes in put_index_data
   updated again. */

netsnmp_variable_list *
dot1dStpPortTable_get_next_data_point(void **my_loop_context,
                                      void **my_data_context,
                                      netsnmp_variable_list *
                                      put_index_data,
                                      netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;
    StpTable_T *tmp;
	tmp=(StpTable_T*)*my_loop_context;
	tmp=tmp->next;
	if(tmp==NULL)
		return NULL;
    
    *my_loop_context =tmp;
    *my_data_context =tmp;
    vptr = put_index_data;

    snmp_set_var_value(vptr, (u_char *)&tmp->stpport,sizeof(int));

    return put_index_data;
}

/** handles requests for the dot1dStpPortTable table, if anything else needs to be done */
int
dot1dStpPortTable_handler(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
	/* each time we must update the stp_info */
	char bname[6];
       memcpy(bname,BRIDGE_IF_NAME,6);
       if(getfdbinfo(bname)<0)
	   printf("init the fdb error");
	   
      /* update the new fdb.info  when change  */
    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    StpTable_T *tmp;
    char command[50];
    netsnmp_variable_list *var;
	/*
    unsigned long *localPortIndex = NULL;
    unsigned long  portId, userPortId;
    static unsigned char designatedPort[2];
    */

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed. 
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the dot1dStpPortTable table in question 
         */
       
         tmp = ( StpTable_T*)netsnmp_extract_iterator_context(request);
        if ( tmp == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            /*
             * XXX: no row existed, if you support creation and this is a
             * set, start dealing with it here, else continue 
             */
        }

        /*
         * extracts the information about the table from the request 
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested 
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request 
         */
        if (table_info == NULL) {
            continue;
        }

        switch (reqinfo->mode) {
         
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_DOT1DSTPPORT:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *)&tmp->stpport,
                                        sizeof(int));
                break;

            case COLUMN_DOT1DSTPPORTPRIORITY:
            /* here we get the respect port value  
           * vaue =get(xx,portId,xx,xx);
           * this value must be relate with portId
           * or fuc(xx,value,portId,xxx);
            */
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *)&tmp->stpport_priority,
                                         sizeof(int) );
                break;

            case COLUMN_DOT1DSTPPORTSTATE:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *)&tmp->stpport_status,
                                         sizeof(int));
                break;

            case COLUMN_DOT1DSTPPORTENABLE:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *)&tmp->stpport_enabled,
                                         sizeof(int));
                break;

            case COLUMN_DOT1DSTPPORTPATHCOST:
                netsnmp_set_request_error(reqinfo, request,
                                  SNMP_NOSUCHINSTANCE);
                break;

            case COLUMN_DOT1DSTPPORTDESIGNATEDROOT:
                snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                         (u_char *)tmp->stp_designatedroot, 8);
                break;

            case COLUMN_DOT1DSTPPORTDESIGNATEDCOST:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *)&tmp->stp_designatedcost
                                         , sizeof(int));
                break;

            case COLUMN_DOT1DSTPPORTDESIGNATEDBRIDGE:
                snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                         (u_char *)&tmp->stp_designatedbridge ,8);
                break;

            case COLUMN_DOT1DSTPPORTDESIGNATEDPORT:
                snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                         (u_char *)tmp->stp_designatedport ,2);
                break;

            case COLUMN_DOT1DSTPPORTFORWARDTRANSITIONS:
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *)&tmp->stp_forwardtransitions
                                         ,sizeof(int) );
                break;

            case COLUMN_DOT1DSTPPORTPATHCOST32:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *)&tmp->stpportpathcost32
                                         ,sizeof(long));
                break;

            default:
                /*
                 * We shouldn't get here 
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in dot1dStpPortTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
        switch (table_info->colnum) {
	    case COLUMN_DOT1DSTPPORTPRIORITY:
                if(var->type!=ASN_INTEGER)
                    netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGTYPE);
                else if(var->val_len!=sizeof(int))
                    netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGLENGTH);
                else if (*var->val.integer<0 ||*var->val.integer>255)
                    netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGVALUE);
                else
                        ;
                break;
            case COLUMN_DOT1DSTPPORTPATHCOST32:
                if(var->type!=ASN_INTEGER)
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGTYPE);
		else if(var->val_len!=sizeof(long))
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGLENGTH);
                else if (*var->val.integer <  1 ||*var->val.integer >  200000000L)
                    netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGVALUE);
                else
			;
                break;  
            case COLUMN_DOT1DSTPPORTPATHCOST:
                netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHINSTANCE);
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,SNMP_ERR_READONLY);
               break;
            }
            break;
			
	case MODE_SET_ACTION:
		switch(table_info->colnum){
	     	case COLUMN_DOT1DSTPPORT:
			break;
            	case COLUMN_DOT1DSTPPORTPRIORITY:
			sprintf(command,"%s setportprio br0 %s %d",BRCTL_PATH,tmp->portname,*var->val.integer);
			system(command);
			break;
            	case COLUMN_DOT1DSTPPORTSTATE:
            	case COLUMN_DOT1DSTPPORTENABLE:
            	case COLUMN_DOT1DSTPPORTPATHCOST:
            	case COLUMN_DOT1DSTPPORTDESIGNATEDROOT:
            	case COLUMN_DOT1DSTPPORTDESIGNATEDCOST:
           	case COLUMN_DOT1DSTPPORTDESIGNATEDBRIDGE:
           	case COLUMN_DOT1DSTPPORTDESIGNATEDPORT:
            	case COLUMN_DOT1DSTPPORTFORWARDTRANSITIONS:
			break;
            	case COLUMN_DOT1DSTPPORTPATHCOST32:
                     sprintf(command,"%s setpathcost br0 %s %d",BRCTL_PATH,tmp->portname,*var->val.integer);
               	     system(command);
                	break;
            	default:                
                snmp_log(LOG_ERR,
                         "problem encountered in dot1dStpPortTable_handler: unknown column\n");
            }
				/* Set operation  sophie to be continue  2005.1.5 */
		break;
        
        default:
            snmp_log(LOG_ERR,
                     "problem encountered in dot1dStpPortTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}



/*********************************************************************
*FDBPort Table routine Begin 
**********************************************************************/

netsnmp_variable_list *
dot1dTpFdbTable_get_first_data_point(void **my_loop_context,
                                     void **my_data_context,
                                     netsnmp_variable_list *
                                     put_index_data,
                                     netsnmp_iterator_info *mydata)
{
    	netsnmp_variable_list *vptr;
	//MACINDEX_T macindex;
	macindex.portindex=1;
	//ffdbindex=1;
	MacstringtoMac(gfdb_info[1].Mac,macindex.mac);
	*my_loop_context = &macindex;
   	*my_data_context = &macindex;
    	vptr = put_index_data;
    	snmp_set_var_value(vptr,(u_char *)macindex.mac,sizeof(u_char)*6);
    return put_index_data;
}

/* if we can get FDBTable these code must be delete it 
*
*Maclist only for Forwarding Data Base  code END 
*/

netsnmp_variable_list *
dot1dTpFdbTable_get_next_data_point(void **my_loop_context,
                                    void **my_data_context,
                                    netsnmp_variable_list * put_index_data,
                                    netsnmp_iterator_info *mydata)
{
 	netsnmp_variable_list *vptr;
 	long *intp=NULL;
	vptr = put_index_data;
	MACINDEX_T *macindexp=NULL;
	macindexp=(MACINDEX_T *)(*my_loop_context);
	macindex.portindex=macindexp->portindex++;
	ffdbindex=macindex.portindex;
	if(ffdbindex+1>gfdbcount)  /* must drop the last one */
		return NULL;
	MacstringtoMac(gfdb_info[ffdbindex].Mac,macindex.mac );
	*my_loop_context=&macindex;
    	*my_data_context =&macindex;
    snmp_set_var_value(vptr, (u_char *)macindex.mac,sizeof(u_char)*6);
	

    return put_index_data;
}


int
dot1dTpFdbTable_handler(netsnmp_mib_handler *handler,
                        netsnmp_handler_registration *reginfo,
                        netsnmp_agent_request_info *reqinfo,
                        netsnmp_request_info *requests)
{
	  /* each time we must update fdb infomation when changed */ 
	 char bname[6];
        memcpy(bname,BRIDGE_IF_NAME,6);
        if(getfdbinfo(bname)<0)
		printf("init the fdb error");	
	  /* update  the new  fdb.info */

	netsnmp_request_info *request;
    	netsnmp_table_request_info *table_info;
    	netsnmp_variable_list *var;
        unsigned char tmpmac[6];
	long * index=NULL;
	MACINDEX_T *macindexp=NULL;
    	long ifindex;
    	unsigned char name[30];
	unsigned char mac[6];
    	for (request = requests; request; request = request->next) {
        	var = request->requestvb;
        	if (request->processed != 0)
            		continue;

        /*
         * perform anything here that you need to do before each
         * request is processed. 
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the dot1dTpFdbTable table in question 
         */
        macindexp= (MACINDEX_T *)netsnmp_extract_iterator_context(request);
        if (macindexp== NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            /*
             * XXX: no row existed, if you support creation and this is a
             * set, start dealing with it here, else continue 
             */
        }
        /*
         * extracts the information about the table from the request 
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested 
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request 
         */

		
        if (table_info == NULL) {
            continue;
        }
		/*get the mac index */
		 mac[0] = var->name[var->name_length - 6];        
		 mac[1] = var->name[var->name_length - 5];        
		 mac[2] = var->name[var->name_length - 4];        
		 mac[3] = var->name[var->name_length - 3];        
		 mac[4] = var->name[var->name_length - 2];        
		 mac[5] = var->name[var->name_length - 1];
		 
		 /* get the table index */
//		ifindex=macindexp->portindex;
		ifindex=searchindexfrommac(mac);
		/* get the table portno */
		portno=gfdb_info[ifindex].portno;
	if( ifindex > gfdbcount )
		{
	netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE); 
		}
        switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here 
             */
        case MODE_GET:

            switch (table_info->colnum) {
            case COLUMN_DOT1DTPFDBADDRESS:

		MacstringtoMac(gfdb_info[ifindex].Mac,tmpmac);
                snmp_set_var_typed_value(var,ASN_OCTET_STR,
                                         (u_char *)tmpmac, 6*sizeof(u_char));
                break;

            case COLUMN_DOT1DTPFDBPORT:
     		snmp_set_var_typed_value(var, ASN_INTEGER,(u_char *)&portno,sizeof(int));
                break;

            case COLUMN_DOT1DTPFDBSTATUS:
				
		if(strcmp(gfdb_info[ifindex].local,"yes")==0)
				value=4; /* self */
            
               else if(strcmp(gfdb_info[ifindex].local,"no")==0)
      
                    		value = 3; /* learned */
		else 
				value=1;/* other */
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &value, sizeof(int));
                break;

            default:
                /*
                 * We shouldn't get here 
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in dot1dTpFdbTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
            /*
             * set handling... 
             */
		break;
        default:
            snmp_log(LOG_ERR,
                     "problem encountered in dot1dTpFdbTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}



/******************************************************************
*BasePortTable routien Begin 
*******************************************************************/

netsnmp_variable_list *
dot1dBasePortTable_get_first_data_point(void **my_loop_context,
                                        void **my_data_context,
                                        netsnmp_variable_list *
                                        put_index_data,
                                        netsnmp_iterator_info *mydata)
{
	//intif_info();
    	netsnmp_variable_list *vptr;
    	unsigned int portindex=1;
  	*my_loop_context = &portindex;
 	*my_data_context =&portindex;

    	vptr = put_index_data;
    	snmp_set_var_value(vptr, (u_char *)&portindex,sizeof(int));
    	return put_index_data;
}

netsnmp_variable_list *
dot1dBasePortTable_get_next_data_point(void **my_loop_context,
                                       void **my_data_context,
                                       netsnmp_variable_list *
                                       put_index_data,
                                       netsnmp_iterator_info *mydata)
{
	netsnmp_variable_list *vptr;
    	unsigned int portindex;
	vptr = put_index_data;
    	portindex= *vptr->val.integer;
    	portindex++;
  	*my_loop_context = &portindex;
  	*my_data_context =&portindex;
  	if((portindex >MAX_PORT_MUM) || (portindex <MIN_PORT_NUM)) return NULL;
    	snmp_set_var_value(vptr, (u_char *)&portindex,sizeof(int));
    	return put_index_data;
}


/** handles requests for the dot1dBasePortTable table, if anything else needs to be done */
int
dot1dBasePortTable_handler(netsnmp_mib_handler *handler,
                           netsnmp_handler_registration *reginfo,
                           netsnmp_agent_request_info *reqinfo,
                           netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
    int *localPortIndex = NULL;
    static unsigned long  portIndex,ifIndex;
    static int portCircuit[] = {0, 0};
    static int value;
	
    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed. 
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the dot1dBasePortTable table in question 
         */

        localPortIndex = (int *)netsnmp_extract_iterator_context(request);
        if (localPortIndex == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }

            /*
             * XXX: no row existed, if you support creation and this is a
             * set, start dealing with it here, else continue 
             */
        }

        /*
         * extracts the information about the table from the request 
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested 
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request 
         */
        if (table_info == NULL) {
            continue;
        }
	portIndex = var->name[var->name_length-1];
	if(portIndex>2 ||portIndex<1)	
	{
		netsnmp_set_request_error(reqinfo, request,SNMP_NOSUCHINSTANCE);
		continue;
	}
	ifIndex=gloub_ifIndex[portIndex-1];


        switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here 
             */
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_DOT1DBASEPORT:

                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &portIndex, sizeof( long));
                break;

            case COLUMN_DOT1DBASEPORTIFINDEX:

                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &ifIndex, sizeof(long));
                break;

            case COLUMN_DOT1DBASEPORTCIRCUIT:

                snmp_set_var_typed_value(var, ASN_OBJECT_ID,
                                         (u_char *) portCircuit,
                                         2 * sizeof(long));
                break;

            case COLUMN_DOT1DBASEPORTDELAYEXCEEDEDDISCARDS:
				 /*from driver ? */
			value =0;
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                        (u_char *) &value, sizeof(int));
                break;

            case COLUMN_DOT1DBASEPORTMTUEXCEEDEDDISCARDS:
				/*from driver ? */
			value=0;
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *) &value, sizeof(int));
                break;

            default:
                /*
                 * We shouldn't get here 
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in dot1dBasePortTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
            /*
             * set handling... 
             */

        default:
            snmp_log(LOG_ERR,
                     "problem encountered in dot1dBasePortTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}

 

/******************************************************************
* TPPortTable routine begin 
******************************************************************/
/*get first index */

netsnmp_variable_list *
dot1dTpPortTable_get_first_data_point(void **my_loop_context,
                                      void **my_data_context,
                                      netsnmp_variable_list *
                                      put_index_data,
                                      netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;

    (void) mydata;
    unsigned int portindex;
    portindex = 1;
    *my_loop_context = &portindex;
    *my_data_context = &portindex;

    vptr = put_index_data;

    snmp_set_var_value(vptr, (u_char *) &portindex, sizeof(int));

    return put_index_data;
}

/* get next operation */

netsnmp_variable_list *
dot1dTpPortTable_get_next_data_point(void **my_loop_context,
                                     void **my_data_context,
                                     netsnmp_variable_list *
                                     put_index_data,
                                     netsnmp_iterator_info *mydata)
{
    int *localPortIndex = ( int *) (*my_loop_context);
    netsnmp_variable_list *vptr;

    (void) mydata;
    unsigned int portindex;
    portindex = *localPortIndex;
    portindex++;

    *my_loop_context = &portindex;
    *my_data_context = &portindex;

    if ((portindex>CB3000_Max_portnum) ||(portindex <CB3000_Min_portnum)) return NULL;

    vptr = put_index_data;

    snmp_set_var_value(vptr, (u_char *) &portindex, sizeof(int));

    return put_index_data;
}

/** handles requests for the dot1dTpPortTable table, if anything else needs to be done */
int
dot1dTpPortTable_handler(netsnmp_mib_handler *handler,
                         netsnmp_handler_registration *reginfo,
                         netsnmp_agent_request_info *reqinfo,
                         netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
    unsigned  int  *localPortIndex = NULL;
    unsigned int  portId;
    int temp1, temp2;
    int value;

    (void)handler;
    (void)reginfo;

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed. 
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the dot1dTpPortTable table in question 
         */
        localPortIndex = (unsigned int *)netsnmp_extract_iterator_context(request);
        if (localPortIndex == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            /*
             * XXX: no row existed, if you support creation and this is a
             * set, start dealing with it here, else continue 
             */
        }

        /*
         * extracts the information about the table from the request 
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested 
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request 
         */
        if (table_info == NULL) {
            continue;
        }

        portId = var->name[var->name_length - 1] - 1;


		 if (portId>CB3000_Max_portnum)
        {
            netsnmp_set_request_error(reqinfo, request,
                                  SNMP_NOSUCHINSTANCE);
            continue;
        }

        switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here 
             */
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_DOT1DTPPORT:

                value = portId + 1;

                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &value, sizeof(int));
                break;

            case COLUMN_DOT1DTPPORTMAXINFO:

                value = DOT1D_MAX_PACKET_SIZE;

                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &value, sizeof(int));
                break;

            case COLUMN_DOT1DTPPORTINFRAMES:
		
                value = temp1 + temp2;

                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *) &value, sizeof(int));
                break;

            case COLUMN_DOT1DTPPORTOUTFRAMES:

                value = temp1 + temp2;

                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *) &value, sizeof(int));
                break;

            case COLUMN_DOT1DTPPORTINDISCARDS:
 			value =5;
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *) &value, sizeof(int));
                break;

            default:
                /*
                 * We shouldn't get here 
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in dot1dTpPortTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
            /*
             * set handling... 
             */

        default:
            snmp_log(LOG_ERR,
                     "problem encountered in dot1dTpPortTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}

#ifdef SOPHIENEED

netsnmp_variable_list *
dot1dStaticTable_get_first_data_point(void **my_loop_context,
                                      void **my_data_context,
                                      netsnmp_variable_list *
                                      put_index_data,
                                      netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;

    *my_loop_context = /* XXX */ ;
    *my_data_context = /* XXX */ ;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) /* XXX: dot1dStaticAddress data */ ,
                       /* XXX: length of dot1dStaticAddress data */ );
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr,
                       (u_char *) /* XXX: dot1dStaticReceivePort data */ ,
                       /* XXX: length of dot1dStaticReceivePort data */ );
    vptr = vptr->next_variable;

    return put_index_data;
}

/** functionally the same as dot1dStaticTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it and the return
   my_loop_context->next.  The my_data_context pointer should be set
   to something you need later and the indexes in put_index_data
   updated again. */

netsnmp_variable_list *
dot1dStaticTable_get_next_data_point(void **my_loop_context,
                                     void **my_data_context,
                                     netsnmp_variable_list *
                                     put_index_data,
                                     netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;

    *my_loop_context = /* XXX */ ;
    *my_data_context = /* XXX */ ;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) /* XXX: dot1dStaticAddress data */ ,
                       /* XXX: length of dot1dStaticAddress data */ );
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr,
                       (u_char *) /* XXX: dot1dStaticReceivePort data */ ,
                       /* XXX: length of dot1dStaticReceivePort data */ );
    vptr = vptr->next_variable;

    return put_index_data;
}

/** handles requests for the dot1dStaticTable table, if anything else needs to be done */
int
dot1dStaticTable_handler(netsnmp_mib_handler *handler,
                         netsnmp_handler_registration *reginfo,
                         netsnmp_agent_request_info *reqinfo,
                         netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed. 
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the dot1dStaticTable table in question 
         */
        /*
         * XXX 
         */  = ( /* XXX */ *)netsnmp_extract_iterator_context(request);
        if ( /* XXX */  == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            /*
             * XXX: no row existed, if you support creation and this is a
             * set, start dealing with it here, else continue 
             */
        }

        /*
         * extracts the information about the table from the request 
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested 
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request 
         */
        if (table_info == NULL) {
            continue;
        }

        switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here 
             */
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_DOT1DSTATICADDRESS:
                snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                         (u_char *) /* XXX: column data */
                                         , /* XXX: column data length */ );
                break;

            case COLUMN_DOT1DSTATICRECEIVEPORT:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) /* XXX: column data */
                                         , /* XXX: column data length */ );
                break;

            case COLUMN_DOT1DSTATICALLOWEDTOGOTO:
                snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                         (u_char *) /* XXX: column data */
                                         , /* XXX: column data length */ );
                break;

            case COLUMN_DOT1DSTATICSTATUS:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) /* XXX: column data */
                                         , /* XXX: column data length */ );
                break;

            default:
                /*
                 * We shouldn't get here 
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in dot1dStaticTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
            /*
             * set handling... 
             */

        default:
            snmp_log(LOG_ERR,
                     "problem encountered in dot1dStaticTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}
#endif


int showMacs(char * bridgename)
{
	char tmp[128];
        sprintf(tmp,"brctl showmacs %s > /tmp/fdb.info",bridgename);
        return system( tmp );
}

int getfdbinfo(char * bridgename)
{
	char tmpname[8];
	memcpy(tmpname,bridgename,6);
	
     	if(showMacs(tmpname)<0)
	{
	 	printf("Macs(fdb) information not correctly ");
		return -1;
	}
        FILE * in;
        int count,n;
        in=fopen("/tmp/fdb.info","r");
        if(in==NULL)
        {
        	printf("Open file:/tmp/fdb.info error!");
        	return -1;
	}
	if(gfdbcount!=0)
	{
		free(gfdb_info);
		gfdbcount=0;
	}
	while(fgetc(in)!='\n');
	while(1)
	{
		n=fgetc(in);
		if(n=='\n')
		{
			++gfdbcount;
			continue;
		}
		if(n==-1)
			break;
	}
	gfdb_info=malloc(gfdbcount*sizeof(ForwardDataBase_T));
	if(gfdb_info==NULL)
	{
		gfdbcount=0;
		return -1;
	}
	fseek(in,0L,SEEK_SET);
	while(fgetc(in)!='\n');
        for(count=0;;++count) 
	{
		n=fscanf(in,"%d %s %s %s",
			&gfdb_info[count].portno,
                   	gfdb_info[count].Mac,
			gfdb_info[count].local,
                   	gfdb_info[count].ageingtime);
		if(n<0)
			break;
                gfdb_info[count].index=count;
        }
 
/* debug information */
/*
     for(i=1;i<gfdbcount;i++)
        {
	printf("%d\n", __LINE__);
        printf("%d %s %s %s %d \n",
        gfdb_info[i].portno,
        gfdb_info[i].Mac,
        gfdb_info[i].local,
        gfdb_info[i].ageingtime,
        (int)gfdb_info[i].index);
	 }
 */
	fclose(in);
	return 0;
}

/* my own code for translate the string mac formate to hex string Mac  */
void  MacstringtoMac(char inmac[18],char retmac[6])
{
	char temp[3];
	int i;
	int aa;
	int bb;
	unsigned char mac[18];
	int intmac[6];
	static unsigned char strmac[6];
	strcpy(mac,inmac);
for(i=0;i<6;i++){	
	temp[0]=mac[3*i];
	temp[1]=mac[3*i+1];
		if(temp[0]>='0'&&temp[0]<='9'){	
    			aa=(temp[0]-48)*16;
    			}
		else if(temp[0]>='a'&& temp[0]<='f')
        		{
        		aa=(temp[0]-87)*16;
        		}
		else{
        		aa= (temp[0]-55)*16;
        		}

	if(temp[1]>='0'&&temp[1]<='9')
    		{
    		bb=(temp[1]-48);
    		}
	else if(temp[1]>='a'&&temp[1]<='f')
        	{
        	bb=(temp[1]-87);
        	}
	else{
        	bb= (temp[1]-55);
        	}

	 intmac[i]=aa+bb;
	 strmac[i]=intmac[i];
	 retmac[i]=strmac[i];
	}

}

int searchindexfrommac(unsigned char mac[6])
{
        unsigned char tmpmac[6];
        int i,j;
        int flag;
        for(i=1;i<gfdbcount;i++)
        {
                MacstringtoMac(gfdb_info[i].Mac,tmpmac);
                for(flag=1,j=0;j<6;j++)
		{
                if(tmpmac[j]!=mac[j])
                {
                   	flag=0;
			break;
                }
		}
		if(flag)
			return i;
        }
        return -1;
}

static int hex2dec(char c)
{
        if(c>='0'&&c<='9')
                return c-'0';
        else if(c>='a'&&c<='f')
                return c-'a'+10;
        else if(c>='A'&&c<='F')
                return c-'A'+10;
        else
                return 0;
}

static void str2hex(char* root, const char* buf)
{
	root[0]=hex2dec(buf[0])*16+hex2dec(buf[1]);
        root[1]=hex2dec(buf[2])*16+hex2dec(buf[3]);
        root[2]=hex2dec(buf[5])*16+hex2dec(buf[6]);
        root[3]=hex2dec(buf[7])*16+hex2dec(buf[8]);
        root[4]=hex2dec(buf[9])*16+hex2dec(buf[10]);
        root[5]=hex2dec(buf[11])*16+hex2dec(buf[12]);
        root[6]=hex2dec(buf[13])*16+hex2dec(buf[14]);
        root[7]=hex2dec(buf[15])*16+hex2dec(buf[16]);	
}

int getstp()
{
	FILE * in;
        char buf[20],check[10];
	char command[50];
        int count;
	int i,n;
	int portindex;
	StpTable_T *tmp,*tail;
	char portname[6];
	char *state[6]={"disabled","blocking","listening","learning","forwarding","broken"};

	for(tmp=gstp_info;tmp;)
	{
		tail=tmp->next;
		free(tmp);
		tmp=tail;
	}
	gstp_info=NULL;
	sprintf(command,"%s showstp br0>/tmp/stp.info",BRCTL_PATH);
	system(command);
        in=fopen("/tmp/stp.info","r");
        if(in==NULL)
        {
        	printf("Open file:/tmp/stp.info error!");
        	return -1;
	}
	count=0;
	for(i=0;i<13;++i)
	{
		while(1)
		{
			n=fgetc(in);
			if(n<0)
			{
				i=100;
				break;
			}
			if(n=='\n')
				break;
		}
	}
	if(i==100)
		return -1;
	for(count=0;count<4;count++)
	{
			//line 1
			n=fscanf(in,"%s %*c%d%*c",portname,&portindex);
			if(n<0)
				break;
			//line 2 1
			fscanf(in,"%s %*s %s",check,buf);
			if(strcmp(check,"port"))
				break;
			tmp=(StpTable_T*)malloc(sizeof(StpTable_T));
			if(tmp==NULL)
				break;
			strcpy(tmp->portname,portname);
			tmp->stpport=portindex;
			tmp->stpport_priority=hex2dec(buf[0])*16+hex2dec(buf[1]);
			//line 2 2
			fscanf(in,"%*s %s",buf);
			for(i=0;i<6;++i)
				if(strcmp(buf,state[i])==0)
					break;
			tmp->stpport_status=(i==6)?i:(i+1);
			
			//line 3 1
			fscanf(in,"%*s %*s %s",buf);
			str2hex(tmp->stp_designatedroot,buf);

			//line 3 2
			fscanf(in,"%*s %*s %d",&tmp->stpportpathcost32);
			
			//line 4 1
			fscanf(in,"%*s %*s %s",buf);
			str2hex(tmp->stp_designatedbridge,buf);
			//line 4 2
			while(fgetc(in)!='\n');
			//line 5 1 
			fscanf(in,"%*s %*s %s",buf);
			tmp->stp_designatedport[0]=hex2dec(buf[2])*16+hex2dec(buf[3]);
                        tmp->stp_designatedport[1]=hex2dec(buf[0])*16+hex2dec(buf[1]);
			//line 5 2
			while(fgetc(in)!='\n');
			// line 6 1
			fscanf(in,"%*s %*s %d",&tmp->stp_designatedcost);
			// line 6 2
			while(fgetc(in)!='\n');
                	//line 7 all
		        while(fgetc(in)!='\n');
			//line 8 all
			while(fgetc(in)!='\n');
		
			tmp->stpport_enabled=1;
			tmp->stp_forwardtransitions=0;
			tmp->next=NULL;
			if(gstp_info==NULL)
				gstp_info=tmp;
			else
				tail->next=tmp;
			tail=tmp;

/*			
			printf("%d\n",tmp->stpport);
			printf("%d\n",tmp->stpport_priority);
			printf("%d\n",tmp->stpport_status);
			printf("%d\n",tmp->stpport_enabled);
			for(i=0;i<8;++i)
				printf("%02x ",tmp->stp_designatedroot[i]);
			printf("\n");
			printf("%d\n",tmp->stp_designatedcost);
			for(i=0;i<8;++i)
                                printf("%02x ",tmp->stp_designatedbridge[i]);
			printf("\n");
			printf("%02x %02x\n",tmp->stp_designatedport[0],tmp->stp_designatedport[1]);
			printf("%d\n", tmp->stp_forwardtransitions);
			printf("%d\n",tmp->stpportpathcost32);
			printf("\n****************************\n");
*/
	}	
	fclose(in);
	 
}
