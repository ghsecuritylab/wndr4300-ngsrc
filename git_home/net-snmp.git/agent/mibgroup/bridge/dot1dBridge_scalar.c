/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
 */
/*********************************************************
* Modified  by Deltanetwork  2004.12.25 --- DNI  
* modules for dot1dbridge, base net-snmp-5.0.9
*  auto generated by  mib2c code and I  merge it to dot1dbridge
***********************************************************/

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "dot1dBridge_scalar.h"
/* bridge-utils  need head files */
#include <net/if.h>
#include <linux/if_bridge.h>
#include <net/if.h>
#include <sys/socket.h>
#include <unistd.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <stdio.h>

/** end */

/* globol variable */
#define brgname "br0"
#define BRIDGE_MAX_NUM	 16 /* here we can support max bridge number  entry */
static int gstpcount;
static int stpflags;
static bridgestp_info_T  gbridge_stp_info[BRIDGE_MAX_NUM];


/** Initializes the dot1dBridge_scalar module */
void
init_dot1dBridge_scalar(void)
{
  //  static oid      newRoot_oid[] = { 1, 3, 6, 1, 2, 1, 17, 0, 1, 0 };
 //   static oid      topologyChange_oid[] =
 //       { 1, 3, 6, 1, 2, 1, 17, 0, 2, 0 };
    static oid      dot1dBaseBridgeAddress_oid[] =
        { 1, 3, 6, 1, 2, 1, 17, 1, 1, 0 };
    static oid      dot1dBaseNumPorts_oid[] =
        { 1, 3, 6, 1, 2, 1, 17, 1, 2, 0 };
    static oid      dot1dBaseType_oid[] =
        { 1, 3, 6, 1, 2, 1, 17, 1, 3, 0 };      
    static oid      dot1dStpProtocolSpecification_oid[] =
        { 1, 3, 6, 1, 2, 1, 17, 2, 1, 0 };
    static oid      dot1dStpPriority_oid[] =
        { 1, 3, 6, 1, 2, 1, 17, 2, 2, 0 };
    static oid      dot1dStpTimeSinceTopologyChange_oid[] =
        { 1, 3, 6, 1, 2, 1, 17, 2, 3, 0 };
   static oid      dot1dStpTopChanges_oid[] =
        { 1, 3, 6, 1, 2, 1, 17, 2, 4, 0 };
   static oid      dot1dStpDesignatedRoot_oid[] =
        { 1, 3, 6, 1, 2, 1, 17, 2, 5, 0 };
  
   static oid      dot1dStpRootCost_oid[] =
        { 1, 3, 6, 1, 2, 1, 17, 2, 6, 0 };    
   static oid      dot1dStpRootPort_oid[] =
        { 1, 3, 6, 1, 2, 1, 17, 2, 7, 0 };
   static oid      dot1dStpMaxAge_oid[] =
        { 1, 3, 6, 1, 2, 1, 17, 2, 8, 0 };
   static oid      dot1dStpHelloTime_oid[] =
        { 1, 3, 6, 1, 2, 1, 17, 2, 9, 0 };
 
    static oid      dot1dStpHoldTime_oid[] =
        { 1, 3, 6, 1, 2, 1, 17, 2, 10, 0 };
    static oid      dot1dStpForwardDelay_oid[] =
        { 1, 3, 6, 1, 2, 1, 17, 2, 11, 0 }; 
    static oid      dot1dStpBridgeMaxAge_oid[] =
        { 1, 3, 6, 1, 2, 1, 17, 2, 12, 0 };
    static oid      dot1dStpBridgeHelloTime_oid[] =
        { 1, 3, 6, 1, 2, 1, 17, 2, 13, 0 };
    static oid      dot1dStpBridgeForwardDelay_oid[] =
        { 1, 3, 6, 1, 2, 1, 17, 2, 14, 0 }; 
	static oid      dot1dTpLearnedEntryDiscards_oid[] =
        { 1, 3, 6, 1, 2, 1, 17, 4, 1, 0 };
    static oid      dot1dTpAgingTime_oid[] =
        { 1, 3, 6, 1, 2, 1, 17, 4, 2, 0 };

	/* init the stpbridge entry */
	
	if(getstpinfo(brgname)==-1)
		stpflags=-1;
	else stpflags=1;
	/* 
	* maybe we will use this flags if stp not start 
	* because global var gbridge_stp_info[0].* not reset 
	* so we must clear it 
	* for example:
	* for(i=0;i<gstpcount;i++)
	* memset(gbridge_stp_info[i],0,sizeof(bridgestp_info_T *));
	* if necessary not display the infomation if stp not on
       */
 /*   */
	
if(stpflags==1)
  {

    DEBUGMSGTL(("dot1dBridge_scalar", "Initializing\n"));

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("dot1dStpBridgeHelloTime",
                               do_dot1dStpBridgeHelloTime,
                               dot1dStpBridgeHelloTime_oid,
                               OID_LENGTH(dot1dStpBridgeHelloTime_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("dot1dTpAgingTime",
                               do_dot1dTpAgingTime,
                               dot1dTpAgingTime_oid,
                               OID_LENGTH(dot1dTpAgingTime_oid),
                               HANDLER_CAN_RWRITE));
/*  
  netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dot1dStpMaxAge",
                                         get_dot1dStpMaxAge,
                                         dot1dStpMaxAge_oid,
                                         OID_LENGTH(dot1dStpMaxAge_oid),
                                         HANDLER_CAN_RONLY));
*/
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dot1dStpDesignatedRoot",
                                         get_dot1dStpDesignatedRoot,
                                         dot1dStpDesignatedRoot_oid,
                                         OID_LENGTH
                                         (dot1dStpDesignatedRoot_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dot1dStpTopChanges",
                                         get_dot1dStpTopChanges,
                                         dot1dStpTopChanges_oid,
                                         OID_LENGTH
                                         (dot1dStpTopChanges_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("dot1dStpBridgeForwardDelay",
                               do_dot1dStpBridgeForwardDelay,
                               dot1dStpBridgeForwardDelay_oid,
                               OID_LENGTH(dot1dStpBridgeForwardDelay_oid),
                               HANDLER_CAN_RWRITE));
/*    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dot1dStpForwardDelay",
                                         get_dot1dStpForwardDelay,
                                         dot1dStpForwardDelay_oid,
                                         OID_LENGTH
                                         (dot1dStpForwardDelay_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dot1dStpHoldTime",
                                         get_dot1dStpHoldTime,
                                         dot1dStpHoldTime_oid,
                                         OID_LENGTH(dot1dStpHoldTime_oid),
                                         HANDLER_CAN_RONLY));
*/    
netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dot1dBaseType",
                                         get_dot1dBaseType,
                                         dot1dBaseType_oid,
                                         OID_LENGTH(dot1dBaseType_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("dot1dStpPriority", do_dot1dStpPriority,
                               dot1dStpPriority_oid,
                               OID_LENGTH(dot1dStpPriority_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("dot1dStpBridgeMaxAge",
                               do_dot1dStpBridgeMaxAge,
                               dot1dStpBridgeMaxAge_oid,
                               OID_LENGTH(dot1dStpBridgeMaxAge_oid),
                               HANDLER_CAN_RWRITE));
/*
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dot1dStpRootCost",
                                         get_dot1dStpRootCost,
                                         dot1dStpRootCost_oid,
                                         OID_LENGTH(dot1dStpRootCost_oid),
                                         HANDLER_CAN_RONLY));
*/
 /*   netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dot1dStpHelloTime",
                                         get_dot1dStpHelloTime,
                                         dot1dStpHelloTime_oid,
                                         OID_LENGTH(dot1dStpHelloTime_oid),
                                         HANDLER_CAN_RONLY));
*/   
 netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dot1dBaseNumPorts",
                                         get_dot1dBaseNumPorts,
                                         dot1dBaseNumPorts_oid,
                                         OID_LENGTH(dot1dBaseNumPorts_oid),
                                         HANDLER_CAN_RONLY));
/*
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("newRoot", get_newRoot,
                                         newRoot_oid,
                                         OID_LENGTH(newRoot_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("topologyChange",
                                         get_topologyChange,
                                         topologyChange_oid,
                                         OID_LENGTH(topologyChange_oid),
                                         HANDLER_CAN_RONLY));
*/
/*
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dot1dStpRootPort",
                                         get_dot1dStpRootPort,
                                         dot1dStpRootPort_oid,
                                         OID_LENGTH(dot1dStpRootPort_oid),
                                         HANDLER_CAN_RONLY));
*/  
  netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dot1dStpProtocolSpecification",
                                         get_dot1dStpProtocolSpecification,
                                         dot1dStpProtocolSpecification_oid,
                                         OID_LENGTH
                                         (dot1dStpProtocolSpecification_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dot1dBaseBridgeAddress",
                                         get_dot1dBaseBridgeAddress,
                                         dot1dBaseBridgeAddress_oid,
                                         OID_LENGTH
                                         (dot1dBaseBridgeAddress_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dot1dStpTimeSinceTopologyChange",
                                         get_dot1dStpTimeSinceTopologyChange,
                                         dot1dStpTimeSinceTopologyChange_oid,
                                         OID_LENGTH
                                         (dot1dStpTimeSinceTopologyChange_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dot1dTpLearnedEntryDiscards",
                                         get_dot1dTpLearnedEntryDiscards,
                                         dot1dTpLearnedEntryDiscards_oid,
                                         OID_LENGTH
                                         (dot1dTpLearnedEntryDiscards_oid),
                                         HANDLER_CAN_RONLY));
   }
 /* if stp off  , not init these,so stp infomation invalid  */ 

}

int
do_dot1dStpBridgeHelloTime(netsnmp_mib_handler *handler,
                           netsnmp_handler_registration *reginfo,
                           netsnmp_agent_request_info *reqinfo,
                           netsnmp_request_info *requests)
{

   	int StpBridgeHellTime;
	netsnmp_variable_list *var;
	var=requests->requestvb;
    switch (reqinfo->mode) {

    case MODE_GET:
	getstpinfo(brgname);
	StpBridgeHellTime=gbridge_stp_info[0].bridge_hello_time[0]*100+gbridge_stp_info[0].bridge_hello_time[1];
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&StpBridgeHellTime,
                                 sizeof(int));
        break;
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
	if (var->type!=ASN_INTEGER) 
        	netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
	else if(var->val_len!=sizeof(long))
		netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGLENGTH);
	else if(*var->val.integer<100 || *var->val.integer>1000)
		netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
	else
		;
    //    if ( tmp>1000 ) {
     //       netsnmp_set_request_error(reqinfo, requests,
    //                                   SNMP_ERR_WRONGVALUE 
   //                                   );
     //   }
        break;

    case MODE_SET_RESERVE2:
        
     //   if ( /* XXX if malloc, or whatever, failed: */ ) {
     //       netsnmp_set_request_error(reqinfo, requests,
 //                                     SNMP_ERR_RESOURCESUNAVAILABLE);
    //    }
        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
        
    //    if (  /* XXX */) {
    //        netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE
   //                                  );
   //     }
  	  	 StpBridgeHellTime=*requests->requestvb->val.integer;
 		setBridgeHellotime(StpBridgeHellTime);
		
        break;

    case MODE_SET_COMMIT:

        /*
         * XXX: delete temporary storage 
         */
   //     if ( /* XXX: error? */ ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
     //       netsnmp_set_request_error(reqinfo, requests,
    //                                  SNMP_ERR_COMMITFAILED);
  //      }
        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */

//        if ( /* XXX: error? */ ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
//            netsnmp_set_request_error(reqinfo, requests,
//                                      SNMP_ERR_UNDOFAILED);
//        }

        break;
    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_dot1dTpAgingTime(netsnmp_mib_handler *handler,
                    netsnmp_handler_registration *reginfo,
                    netsnmp_agent_request_info *reqinfo,
                    netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */
     
    	int Tpagingtime;
	netsnmp_variable_list *var;
	var=requests->requestvb;
    switch (reqinfo->mode) {

    case MODE_GET:
	getstpinfo(brgname);
	Tpagingtime=gbridge_stp_info[0].ageing_time[0];
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&Tpagingtime,sizeof(int)
                                 );
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        if (var->type!=ASN_INTEGER) 
        	netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
	else if(var->val_len!=sizeof(long))
		netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGLENGTH);
	else if(*var->val.integer<10 || *var->val.integer>1000000)
		netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
	else
		;
	break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */
     //   if ( /* XXX if malloc, or whatever, failed: */ ) {
     //       netsnmp_set_request_error(reqinfo, requests,
    //                                  SNMP_ERR_RESOURCESUNAVAILABLE);
     //   }
        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
      
    	 Tpagingtime=*requests->requestvb->val.integer;
	 setAgeingtime(Tpagingtime);
        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */
      //  if ( /* XXX: error? */ ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
      //      netsnmp_set_request_error(reqinfo, requests,
    //                                  SNMP_ERR_COMMITFAILED);
   //     }
        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */
     //   if ( /* XXX: error? */ ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
    //        netsnmp_set_request_error(reqinfo, requests,
    //                                  SNMP_ERR_UNDOFAILED);
  //      }
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dot1dStpMaxAge(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */
 static   int StpBridgeMaxAge;

    switch (reqinfo->mode) {

    case MODE_GET:
		
	  StpBridgeMaxAge=gbridge_stp_info[0].max_age[0];
         snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&StpBridgeMaxAge,sizeof(int)
                                 );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dot1dStpDesignatedRoot(netsnmp_mib_handler *handler,
                           netsnmp_handler_registration *reginfo,
                           netsnmp_agent_request_info *reqinfo,
                           netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

	unsigned char StpDesignatedRoot[8];
	int i;
    switch (reqinfo->mode) {

    case MODE_GET:
		for(i=0;i<8;i++)
		StpDesignatedRoot[i]=gbridge_stp_info[0].designated_root[i];
		printf("%2x %2x\n",gbridge_stp_info[0].designated_root[0],gbridge_stp_info[0].designated_root[1]);
        	snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)StpDesignatedRoot,8*sizeof(unsigned char)
                                 );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dot1dStpTopChanges(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info *reqinfo,
                       netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */
	static long dot1dStpTopChanges=0;
    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
                                (u_char*)&dot1dStpTopChanges,sizeof(long)
                                 );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_dot1dStpBridgeForwardDelay(netsnmp_mib_handler *handler,
                              netsnmp_handler_registration *reginfo,
                              netsnmp_agent_request_info *reqinfo,
                              netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */
	 int StpBridgeForwardDelay;
	netsnmp_variable_list *var;
	var=requests->requestvb;
    switch (reqinfo->mode) {

    case MODE_GET:
	getstpinfo(brgname);
	StpBridgeForwardDelay=gbridge_stp_info[0].bridge_forward_delay[0]*100+gbridge_stp_info[0].bridge_forward_delay[1];
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                (u_char *)&StpBridgeForwardDelay,sizeof(int)
                               
                                 );
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
	if (var->type!=ASN_INTEGER) 
        	netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
	else if(var->val_len!=sizeof(long))
		netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGLENGTH);
	else if(*var->val.integer<400 || *var->val.integer>3000)
		netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
	else
		;
      //  if ( /* XXX: check incoming data in requests->requestvb->val.XXX for failures, like an incorrect type or an illegal value or ... */ ) {
     //       netsnmp_set_request_error(reqinfo, requests,
     //                                 /* XXX: set error code depending on problem (like SNMP_ERR_WRONGTYPE or SNMP_ERR_WRONGVALUE or ... */
     //                                 );
//        }
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */
     //   if ( /* XXX if malloc, or whatever, failed: */ ) {
     //       netsnmp_set_request_error(reqinfo, requests,
     //                                 SNMP_ERR_RESOURCESUNAVAILABLE);
   //     }
        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
        /*
         * XXX: perform the value change here 
         */
    //    if ( /* XXX: error? */ ) {
     //       netsnmp_set_request_error(reqinfo, requests, /* some error */
   //                                   );
   //     }
   
   		StpBridgeForwardDelay=*requests->requestvb->val.integer;
		SetStpBridgeForwardDelay(StpBridgeForwardDelay);
        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */
     //   if ( /* XXX: error? */ ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
   //         netsnmp_set_request_error(reqinfo, requests,
   //                                   SNMP_ERR_COMMITFAILED);
    //    }
        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */
  //      if ( /* XXX: error? */ ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
  //          netsnmp_set_request_error(reqinfo, requests,
  //                                    SNMP_ERR_UNDOFAILED);
   //     }
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dot1dStpForwardDelay(netsnmp_mib_handler *handler,
                         netsnmp_handler_registration *reginfo,
                         netsnmp_agent_request_info *reqinfo,
                         netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */
     int stpforwarddelay;

    switch (reqinfo->mode) {

    case MODE_GET:
		stpforwarddelay=gbridge_stp_info[0].forward_delay[0];
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&stpforwarddelay,
                                 sizeof(int));
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dot1dStpHoldTime(netsnmp_mib_handler *handler,
                     netsnmp_handler_registration *reginfo,
                     netsnmp_agent_request_info *reqinfo,
                     netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

	int stpholdtime=800;
    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&stpholdtime,
                                sizeof(int));
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
get_dot1dBaseType(netsnmp_mib_handler *handler,
                  netsnmp_handler_registration *reginfo,
                  netsnmp_agent_request_info *reqinfo,
                  netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */
     
     static int dot1dBaseType;

    switch (reqinfo->mode) {
	case MODE_GET:
 		dot1dBaseType =BASE_TYPE_TRANSPARENT_ONLY ;

        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&dot1dBaseType,
                                 sizeof(int));
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

static int hex2dec(char c)
{
        if(c>='0'&&c<='9')
                return c-'0';
        else if(c>='a'&&c<='f')
                return c-'a'+10;
        else if(c>='A'&&c<='F')
                return c-'A'+10;
        else
                return 0;
}


int
do_dot1dStpPriority(netsnmp_mib_handler *handler,
                    netsnmp_handler_registration *reginfo,
                    netsnmp_agent_request_info *reqinfo,
                    netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */
	
      int stppriority;
	netsnmp_variable_list *var;
	var=requests->requestvb;
	char tmp[5];
    switch (reqinfo->mode) {

    case MODE_GET:
	getstpinfo(brgname);
        sprintf(tmp,"%2x%2x",gbridge_stp_info[0].bridge_id.prio[0],gbridge_stp_info[0].bridge_id.prio[1]);
        stppriority=hex2dec(tmp[0])*4096+hex2dec(tmp[1])*256+hex2dec(tmp[2])*16+hex2dec(tmp[3]);
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&stppriority,sizeof(int)
                                 );
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
	if (var->type!=ASN_INTEGER) 
        	netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
	else if(var->val_len!=sizeof(long))
		netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGLENGTH);
	else if(*var->val.integer<0 || *var->val.integer>65535)
		netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
	else
		;
     //   if ( /* XXX: check incoming data in requests->requestvb->val.XXX for failures, like an incorrect type or an illegal value or ... */ ) {
     //       netsnmp_set_request_error(reqinfo, requests,
     //                                 /* XXX: set error code depending on problem (like SNMP_ERR_WRONGTYPE or SNMP_ERR_WRONGVALUE or ... */
    //                                  );
    //    }
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */
     //   if ( /* XXX if malloc, or whatever, failed: */ ) {
     //       netsnmp_set_request_error(reqinfo, requests,
    //                                  SNMP_ERR_RESOURCESUNAVAILABLE);
     //   }
        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
        /*
         * XXX: perform the value change here 
         */
      //  if ( /* XXX: error? */ ) {
     //       netsnmp_set_request_error(reqinfo, requests, /* some error */
    //                                  );
      //  }
           stppriority=*requests->requestvb->val.integer;
		SetStpPriority(stppriority);
		
        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */
//        if ( /* XXX: error? */ ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
   //         netsnmp_set_request_error(reqinfo, requests,
  //                                    SNMP_ERR_COMMITFAILED);
   //     }
        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */
  //      if ( /* XXX: error? */ ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
     //       netsnmp_set_request_error(reqinfo, requests,
    //                                  SNMP_ERR_UNDOFAILED);
    //    }
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_dot1dStpBridgeMaxAge(netsnmp_mib_handler *handler,
                        netsnmp_handler_registration *reginfo,
                        netsnmp_agent_request_info *reqinfo,
                        netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */
     	int stpbridgemaxage;
	netsnmp_variable_list *var;
	var=requests->requestvb;
    switch (reqinfo->mode) {

    case MODE_GET:
	getstpinfo(brgname);
	stpbridgemaxage=gbridge_stp_info[0].bridge_max_age[0]*100+gbridge_stp_info[0].bridge_max_age[1];
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&stpbridgemaxage,sizeof(int)
                                 );
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
	if(var->type!=ASN_INTEGER) 
        	netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
	else if(var->val_len!=sizeof(long))
		netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGLENGTH);
	else if(*var->val.integer<600 || *var->val.integer>4000)
		netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
	else
		;
      //  if ( /* XXX: check incoming data in requests->requestvb->val.XXX for failures, like an incorrect type or an illegal value or ... */ ) {
       //     netsnmp_set_request_error(reqinfo, requests,
                                      /* XXX: set error code diepending on problem (like SNMP_ERR_WRONGTYPE or SNMP_ERR_WRONGVALUE or ... */
      //                                );
//        }
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */
    //    if ( /* XXX if malloc, or whatever, failed: */ ) {
     //       netsnmp_set_request_error(reqinfo, requests,
     //                                 SNMP_ERR_RESOURCESUNAVAILABLE);
    //    }
        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
        /*
         * XXX: perform the value change here 
         */
   //     if ( /* XXX: error? */ ) {
     //       netsnmp_set_request_error(reqinfo, requests, /* some error */
   //                                   );
   //     }
		stpbridgemaxage=*requests->requestvb->val.integer;
		SetSptBridgeMaxAge(stpbridgemaxage);
		
        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */
     //   if ( /* XXX: error? */ ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
     //       netsnmp_set_request_error(reqinfo, requests,
      //                                SNMP_ERR_COMMITFAILED);
     //   }
        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */
    //    if ( /* XXX: error? */ ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
   //         netsnmp_set_request_error(reqinfo, requests,
    //                                  SNMP_ERR_UNDOFAILED);
    //    }
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dot1dStpRootCost(netsnmp_mib_handler *handler,
                     netsnmp_handler_registration *reginfo,
                     netsnmp_agent_request_info *reqinfo,
                     netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

		int stpRootCost;
    switch (reqinfo->mode) {

    case MODE_GET:
		stpRootCost=gbridge_stp_info[0].path_cost;
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&stpRootCost,
                                 sizeof(int));
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dot1dStpHelloTime(netsnmp_mib_handler *handler,
                      netsnmp_handler_registration *reginfo,
                      netsnmp_agent_request_info *reqinfo,
                      netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

	/* get helltime */
	int stphelltime;

    switch (reqinfo->mode) {

    case MODE_GET:
		stphelltime=gbridge_stp_info[0].hello_time[0];
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&stphelltime,sizeof(int));
                                
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dot1dBaseNumPorts(netsnmp_mib_handler *handler,
                      netsnmp_handler_registration *reginfo,
                      netsnmp_agent_request_info *reqinfo,
                      netsnmp_request_info *requests)
{
    


	static int BaseNoPort=2;
    switch (reqinfo->mode) {

    case MODE_GET:
		/* test get I give the dev bridge  base port no 6 */
		
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&BaseNoPort,sizeof(int));
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/* single scalar oid routines */

#ifdef NEED  /* no need now */
int
get_newRoot(netsnmp_mib_handler *handler,
            netsnmp_handler_registration *reginfo,
            netsnmp_agent_request_info *reqinfo,
            netsnmp_request_info *requests)
{

   static int bridgeroot=1;
    switch (reqinfo->mode) {

    case MODE_GET:

        snmp_set_var_typed_value(requests->requestvb,ASN_INTEGER,
                                 (u_char *)&bridgeroot,sizeof(int));

        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
get_topologyChange(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{

	/* if stp start topology change can get */
	static int topologychange=1000;
	
    switch (reqinfo->mode) {

    case MODE_GET:

        snmp_set_var_typed_value(requests->requestvb,ASN_INTEGER,
                                 (u_char *)&topologychange,sizeof(int));

        break;
    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

#endif


int
get_dot1dStpRootPort(netsnmp_mib_handler *handler,
                     netsnmp_handler_registration *reginfo,
                     netsnmp_agent_request_info *reqinfo,
                     netsnmp_request_info *requests)
{
	/* if brg's port stp start  the information can get */

		int stprootport;
   	
    switch (reqinfo->mode) {

    case MODE_GET:
		stprootport=gbridge_stp_info[0].root_port;
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&stprootport,sizeof(int)
                                 );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dot1dStpProtocolSpecification(netsnmp_mib_handler *handler,
                                  netsnmp_handler_registration *reginfo,
                                  netsnmp_agent_request_info *reqinfo,
                                  netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */
    static int stpprotcalSecf=STP_PROTOCOL_SPEC_IEEE8021D;
    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&stpprotcalSecf,sizeof(int)
                                 );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
get_dot1dBaseBridgeAddress(netsnmp_mib_handler *handler,
                           netsnmp_handler_registration *reginfo,
                           netsnmp_agent_request_info *reqinfo,
                           netsnmp_request_info *requests)
{
    	static unsigned char  mac[6];
		static char brname[20];
		/* test on PC */
	//	memcpy(brname,"eth0",6);
		memcpy(brname,brgname,6);
		if(getmacbyifname(brname,mac)<0)
				return 0;
    switch (reqinfo->mode) {

    case MODE_GET:

	/* here we must get the mac of BC3000 bridge address */
	/* now I give the manule  mac  */

        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)mac, 6);
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
get_dot1dStpTimeSinceTopologyChange(netsnmp_mib_handler *handler,
                                    netsnmp_handler_registration *reginfo,
                                    netsnmp_agent_request_info *reqinfo,
                                    netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

	unsigned long stpsincetopologychange=0;
	
    switch (reqinfo->mode) {

    case MODE_GET:
		
        snmp_set_var_typed_value(requests->requestvb, ASN_TIMETICKS,
                                 (u_char *)&stpsincetopologychange,
                                 sizeof(unsigned long));
                            
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dot1dTpLearnedEntryDiscards(netsnmp_mib_handler *handler,
                                netsnmp_handler_registration *reginfo,
                                netsnmp_agent_request_info *reqinfo,
                                netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */
     
	unsigned long Tplearneded=0;
    switch (reqinfo->mode) {

    case MODE_GET:
		
        snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
                                 (u_char *)&Tplearneded,
                                 sizeof(unsigned long));
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int showstp(char * bridgename)
{
	char tmp[128];
        sprintf(tmp,"brctl showstp  %s> /tmp/bridgestp.info",bridgename);
        return system( tmp );

}
int getstpinfo(char * bridgename){
        FILE * fp;
       // char line[1024];
        int count;
	 char bname[8] ,buf[20],check[20];
	 strncpy(bname,bridgename,5);
	/* first of all ,we must put bridge information to file */
    	if(showstp(brgname)==-1)
	{
	 	printf("getstp information error  ");
		return -1;
	}
        fp=fopen("/tmp/bridgestp.info","r");
        if(fp==NULL)
        {
        	printf("Open file:/tmp/bridgestp.info error!");
        	return -1;
	}
        count=0;
	while(fgetc(fp)!='\n');
	fscanf(fp,"%s %*s %s",check,buf);
	if(strcmp(check,"bridge")!=0)
		return -1;
	gbridge_stp_info[count].bridge_id.prio[0]=hex2dec(buf[0])*16+hex2dec(buf[1]);
	gbridge_stp_info[count].bridge_id.prio[1]=hex2dec(buf[2])*16+hex2dec(buf[3]);
	gbridge_stp_info[count].bridge_id.addr[0]=hex2dec(buf[5])*16+hex2dec(buf[6]);
	gbridge_stp_info[count].bridge_id.addr[1]=hex2dec(buf[7])*16+hex2dec(buf[8]);
	gbridge_stp_info[count].bridge_id.addr[2]=hex2dec(buf[9])*16+hex2dec(buf[10]);
	gbridge_stp_info[count].bridge_id.addr[3]=hex2dec(buf[11])*16+hex2dec(buf[12]);
	gbridge_stp_info[count].bridge_id.addr[4]=hex2dec(buf[13])*16+hex2dec(buf[14]);
	gbridge_stp_info[count].bridge_id.addr[5]=hex2dec(buf[15])*16+hex2dec(buf[16]);
	fscanf(fp,"%*s %*s %s",buf);
	gbridge_stp_info[count].designated_root[0]=hex2dec(buf[0])*16+hex2dec(buf[1]);
	gbridge_stp_info[count].designated_root[1]=hex2dec(buf[2])*16+hex2dec(buf[3]);
	gbridge_stp_info[count].designated_root[2]=hex2dec(buf[5])*16+hex2dec(buf[6]);
	gbridge_stp_info[count].designated_root[3]=hex2dec(buf[7])*16+hex2dec(buf[8]);
	gbridge_stp_info[count].designated_root[4]=hex2dec(buf[9])*16+hex2dec(buf[10]);
	gbridge_stp_info[count].designated_root[5]=hex2dec(buf[11])*16+hex2dec(buf[12]);
	gbridge_stp_info[count].designated_root[6]=hex2dec(buf[13])*16+hex2dec(buf[14]);
	gbridge_stp_info[count].designated_root[7]=hex2dec(buf[15])*16+hex2dec(buf[16]);
		
/*
	fscanf(fp,"%*s %*s %02x%02x.%02x%02x%02x%02x%02x%02x",buf1,buf2,&gbridge_stp_info[count].bridge_id.prio[0],&gbridge_stp_info[count].bridge_id.prio[1],&gbridge_stp_info[count].bridge_id.addr[0],&gbridge_stp_info[count].bridge_id.addr[1],&gbridge_stp_info[count].bridge_id.addr[2],&gbridge_stp_info[count].bridge_id.addr[3],&gbridge_stp_info[count].bridge_id.addr[4],&gbridge_stp_info[count].bridge_id.addr[5]);

	fscanf(fp,"%*s %*s %2x%2x.%2x%2x%2x%2x%2x%2x",buf1,buf2,&gbridge_stp_info[count].designated_root[0],&gbridge_stp_info[count].designated_root[1],&gbridge_stp_info[count].designated_root[2],&gbridge_stp_info[count].designated_root[3],&gbridge_stp_info[count].designated_root[4],&gbridge_stp_info[count].designated_root[5],&gbridge_stp_info[count].designated_root[6],&gbridge_stp_info[count].designated_root[7]);
*/
	fscanf(fp,"%*s %*s %d %*s %*s %d",&gbridge_stp_info[count].root_port,&gbridge_stp_info[count].path_cost);
	fscanf(fp,"%*s %*s %d.%d %*s %*s %*s %d.%d",&gbridge_stp_info[count].max_age[0],&gbridge_stp_info[count].max_age[1],&gbridge_stp_info[count].bridge_max_age[0],&gbridge_stp_info[count].bridge_max_age[1]);
	fscanf(fp,"%*s %*s %d.%d %*s %*s %*s %d.%d",&gbridge_stp_info[count].hello_time[0],&gbridge_stp_info[count].hello_time[1],&gbridge_stp_info[count].bridge_hello_time[0],&gbridge_stp_info[count].bridge_hello_time[1]);
	fscanf(fp,"%*s %*s %d.%d %*s %*s %*s %d.%d",&gbridge_stp_info[count].forward_delay[0],&gbridge_stp_info[count].forward_delay[1],&gbridge_stp_info[count].bridge_forward_delay[0],&gbridge_stp_info[count].bridge_forward_delay[1]);
	fscanf(fp,"%*s %*s %d.%d",&gbridge_stp_info[count].ageing_time[0],&gbridge_stp_info[count].ageing_time[1]);
	fscanf(fp,"%*s %*s %d.%d %*s %*s %d.%d",&gbridge_stp_info[count].hello_timer[0],&gbridge_stp_info[count].hello_timer[1],&gbridge_stp_info[count].tcn_timer[0],&gbridge_stp_info[count].tcn_timer[1]);
	fscanf(fp,"%*s %*s %*s %d.%d %*s %*s %d.%d",&gbridge_stp_info[count].topology_change_timer[0],&gbridge_stp_info[count].topology_change_timer[1],&gbridge_stp_info[count].gc_timer[0],&gbridge_stp_info[count].gc_timer[1]);
/*
	printf("%2x%2x.%2x%2x%2x%2x%2x%2x\n",gbridge_stp_info[count].bridge_id.prio[0],gbridge_stp_info[count].bridge_id.prio[1],gbridge_stp_info[count].bridge_id.addr[0],gbridge_stp_info[count].bridge_id.addr[1],gbridge_stp_info[count].bridge_id.addr[2],gbridge_stp_info[count].bridge_id.addr[3],gbridge_stp_info[count].bridge_id.addr[4],gbridge_stp_info[count].bridge_id.addr[5]);
	printf("%2x%2x.%2x%2x%2x%2x%2x%2x\n",gbridge_stp_info[count].designated_root[0],gbridge_stp_info[count].designated_root[1],gbridge_stp_info[count].designated_root[2],gbridge_stp_info[count].designated_root[3],gbridge_stp_info[count].designated_root[4],gbridge_stp_info[count].designated_root[5],gbridge_stp_info[count].designated_root[6],gbridge_stp_info[count].designated_root[7]);
	printf(" %d  %d\n",gbridge_stp_info[count].root_port,gbridge_stp_info[count].path_cost);
	printf("%d.%d %d.%d\n",gbridge_stp_info[count].max_age[0],gbridge_stp_info[count].max_age[1],gbridge_stp_info[count].bridge_max_age[0],gbridge_stp_info[count].bridge_max_age[1]);
	printf("%d.%d %d.%d\n",gbridge_stp_info[count].hello_time[0],gbridge_stp_info[count].hello_time[1],gbridge_stp_info[count].bridge_hello_time[0],gbridge_stp_info[count].bridge_hello_time[1]);
	printf("%d.%d %d.%d\n",gbridge_stp_info[count].forward_delay[0],gbridge_stp_info[count].forward_delay[1],gbridge_stp_info[count].bridge_forward_delay[0],gbridge_stp_info[count].bridge_forward_delay[1]);
	printf("%d.%d\n",gbridge_stp_info[count].ageing_time[0],gbridge_stp_info[count].ageing_time[1]);
	printf("%d.%d %d.%d\n",gbridge_stp_info[count].hello_timer[0],gbridge_stp_info[count].hello_timer[1],gbridge_stp_info[count].tcn_timer[0],gbridge_stp_info[count].tcn_timer[1]);
	printf("%d.%d %d.%d\n",gbridge_stp_info[count].topology_change_timer[0],gbridge_stp_info[count].topology_change_timer[1],gbridge_stp_info[count].gc_timer[0],gbridge_stp_info[count].gc_timer[1]);


*/


/*

 while (line == fgets(line, sizeof(line), in)) {
        if(strncmp(line,"br",2)==0)
                sscanf(line,"%s",gbridge_stp_info[count].bname);
	else if(!strncmp(line," STP is disabled for this interface",4))
		{
			printf("STP not enable now");
			return -1;
		} 
        else if (!strncmp(line," bridge id", 10))
            sscanf(line, " bridge id\t\t%2x%2x.%2x%2x%2x%2x%2x%2x",&gbridge_stp_info[count].bridge_id.prio[0],&gbridge_stp_info[count].bridge_id.prio[1],&gbridge_stp_info[count].bridge_id.addr[0],&gbridge_stp_info[count].bridge_id.addr[1],&gbridge_stp_info[count].bridge_id.addr[2],&gbridge_stp_info[count].bridge_id.addr[3],&gbridge_stp_info[count].bridge_id.addr[4],&gbridge_stp_info[count].bridge_id.addr[5]);
        else if (!strncmp(line," designated root", 16))
            sscanf(line, " designated root\t%2x%2x.%2x%2x%2x%2x%2x%2x",&gbridge_stp_info[count].designated_root[0],&gbridge_stp_info[count].designated_root[1],&gbridge_stp_info[count].designated_root[2],&gbridge_stp_info[count].designated_root[3],&gbridge_stp_info[count].designated_root[4],&gbridge_stp_info[count].designated_root[5],&gbridge_stp_info[count].designated_root[6],&gbridge_stp_info[count].designated_root[7]);
        else if (!strncmp(line," root port", 9))
                sscanf(line, " root port\t\t%4i\t\t\tpath cost\t\t%2i",&gbridge_stp_info[count].root_port,&gbridge_stp_info[count].path_cost);
        else if(!strncmp(line," max age",8))
                sscanf(line," max age\t\t%4i.%2i\t\tbridge max age%4i.%2i\t\t",&gbridge_stp_info[count].max_age[0],&gbridge_stp_info[count].max_age[1],&gbridge_stp_info[count].bridge_max_age[0],&gbridge_stp_info[count].bridge_max_age[1]);
        else if(strncmp(line," hello time",11)==0&&(strncmp(line," hello timer",12))<0)
                sscanf(line," hello time\t\t%4i.%2i\t\t\tbridge hello time\t%4i.%2i",&gbridge_stp_info[count].hello_time[0],&gbridge_stp_info[count].hello_time[1],&gbridge_stp_info[count].bridge_hello_time[0],&gbridge_stp_info[count].bridge_hello_time[1]);
        else if(!strncmp(line," forward delay",14))
                sscanf(line," forward delay\t\t%4i.%2i\t\t\tbridge forward delay\t%4i.%2i",&gbridge_stp_info[count].forward_delay[0],&gbridge_stp_info[count].forward_delay[1],&gbridge_stp_info[count].bridge_forward_delay[0],&gbridge_stp_info[count].bridge_forward_delay[1]);
        else if(!strncmp(line," ageing time",9))
                sscanf(line," ageing time\t\t%4i.%2i\t\t\tgc interval\t\t%4i.%2i",&gbridge_stp_info[count].ageing_time[0],&gbridge_stp_info[count].ageing_time[1],&gbridge_stp_info[count].gc_interval[0],&gbridge_stp_info[count].gc_interval[1]);
        else if(strncmp(line," hello timer",12)==0)
                sscanf(line," hello timer\t\t%4i.%2i\t\t\ttcn timer\t\t%4i.%2i",&gbridge_stp_info[count].hello_timer[0],&gbridge_stp_info[count].hello_timer[1],&gbridge_stp_info[count].tcn_timer[0],&gbridge_stp_info[count].tcn_timer[1]);

        else if(!strncmp(line," topology change timer",22))
                sscanf(line," topology change timer\t%4i.%2i\t\t\tgc timer\t\t%4i.%2i",&gbridge_stp_info[count].topology_change_timer[0],&gbridge_stp_info[count].topology_change_timer[1],&gbridge_stp_info[count].gc_timer[0],&gbridge_stp_info[count].gc_timer[1]);
        else if(!strncmp(line ," flags",6))
                sscanf(line," flags\t\t\t%d",&gbridge_stp_info[count].flags);
        }

	
	printf("%2x%2x.%2x%2x%2x%2x%2x%2x\n",gbridge_stp_info[count].bridge_id.prio[0],gbridge_stp_info[count].bridge_id.prio[1],gbridge_stp_info[count].bridge_id.addr[0],gbridge_stp_info[count].bridge_id.addr[1],gbridge_stp_info[count].bridge_id.addr[2],gbridge_stp_info[count].bridge_id.addr[3],gbridge_stp_info[count].bridge_id.addr[4],gbridge_stp_info[count].bridge_id.addr[5]);
        printf("%2x%2x.%2x%2x%2x%2x%2x%2x\n",gbridge_stp_info[count].designated_root[0],gbridge_stp_info[count].designated_root[1],gbridge_stp_info[count].designated_root[2],gbridge_stp_info[count].designated_root[3],gbridge_stp_info[count].designated_root[4],gbridge_stp_info[count].designated_root[5],gbridge_stp_info[count].designated_root[6],gbridge_stp_info[count].designated_root[7]);
        printf(" %d  %d\n",gbridge_stp_info[count].root_port,gbridge_stp_info[count].path_cost);
        printf("%d.%d %d.%d\n",gbridge_stp_info[count].max_age[0],gbridge_stp_info[count].max_age[1],gbridge_stp_info[count].bridge_max_age[0],gbridge_stp_info[count].bridge_max_age[1]);
        printf("%d.%d %d.%d\n",gbridge_stp_info[count].hello_time[0],gbridge_stp_info[count].hello_time[1],gbridge_stp_info[count].bridge_hello_time[0],gbridge_stp_info[count].bridge_hello_time[1]);
        printf("%d.%d %d.%d\n",gbridge_stp_info[count].forward_delay[0],gbridge_stp_info[count].forward_delay[1],gbridge_stp_info[count].bridge_forward_delay[0],gbridge_stp_info[count].bridge_forward_delay[1]);
        printf("%d.%d\n",gbridge_stp_info[count].ageing_time[0],gbridge_stp_info[count].ageing_time[1]);
        printf("%d.%d %d.%d\n",gbridge_stp_info[count].hello_timer[0],gbridge_stp_info[count].hello_timer[1],gbridge_stp_info[count].tcn_timer[0],gbridge_stp_info[count].tcn_timer[1]);
        printf("%d.%d %d.%d\n",gbridge_stp_info[count].topology_change_timer[0],gbridge_stp_info[count].topology_change_timer[1],gbridge_stp_info[count].gc_timer[0],gbridge_stp_info[count].gc_timer[1]);



	
/* now I only use br0 ,if more than one bridge ,the count++ 
* so now we only use the globle variable gbridge_stp_info[0]	
*/
  //      count++; 
//	gstpcount=count;
/* debug information */
/*
printf(" bridge_name \t\t%s\n bridge_id \t\t%.2x%.2x.%.2x%.2x%.2x%.2x%.2x%.2x\n designed_root \t\t %.2x%.2x.%.2x%.2x%.2x%.2x%.2x%.2x\n root_port  \t\t%d\n path_cost \t\t%d\n max_age \t\t%d.%d\n bridge_max_age \t%d.%d\n hello_time \t\t%d.%d\n bridge_hello_time \t%d.%d\n forward_delay \t\t%d.%d\n bridge_forward_delay \t%d.%d\n ageing time \t\t%d.%d\n gc_interval \t\t%d.%d\n hello_timer \t\t%d.%d\n tcn_timer \t\t%d.%d\n topology_change_timer  %d.%d\n gc_timer  \t\t%d.%d\n flags %d",
gbridge_stp_info[0].bname,
gbridge_stp_info[0].bridge_id.prio[0],
gbridge_stp_info[0].bridge_id.prio[1],
gbridge_stp_info[0].bridge_id.addr[0],
gbridge_stp_info[0].bridge_id.addr[1],
gbridge_stp_info[0].bridge_id.addr[2],
gbridge_stp_info[0].bridge_id.addr[3],
gbridge_stp_info[0].bridge_id.addr[4],
gbridge_stp_info[0].bridge_id.addr[5],
gbridge_stp_info[0].designated_root[0],
gbridge_stp_info[0].designated_root[1],
gbridge_stp_info[0].designated_root[2],
gbridge_stp_info[0].designated_root[3],
gbridge_stp_info[0].designated_root[4],
gbridge_stp_info[0].designated_root[5],
gbridge_stp_info[0].designated_root[6],
gbridge_stp_info[0].designated_root[7],
gbridge_stp_info[0].root_port,
gbridge_stp_info[0].path_cost,
gbridge_stp_info[0].max_age[0],
gbridge_stp_info[0].max_age[1],
gbridge_stp_info[0].bridge_max_age[0],
gbridge_stp_info[0].bridge_max_age[1],
gbridge_stp_info[0].hello_time[0],
gbridge_stp_info[0].hello_time[1],
gbridge_stp_info[0].bridge_hello_time[0],
gbridge_stp_info[0].bridge_hello_time[1],
gbridge_stp_info[0].forward_delay[0],
gbridge_stp_info[0].forward_delay[1],
gbridge_stp_info[0].bridge_forward_delay[0],
gbridge_stp_info[0].bridge_forward_delay[1],
gbridge_stp_info[0].ageing_time[0],
gbridge_stp_info[0].ageing_time[1],
gbridge_stp_info[0].gc_interval[0],
gbridge_stp_info[0].gc_interval[1],
gbridge_stp_info[0].hello_timer[0],
gbridge_stp_info[0].hello_timer[1],
gbridge_stp_info[0].tcn_timer[0],
gbridge_stp_info[0].tcn_timer[1],
gbridge_stp_info[0].topology_change_timer[0],
gbridge_stp_info[0].topology_change_timer[1],
gbridge_stp_info[0].gc_timer[0],
gbridge_stp_info[0].gc_timer[1],
gbridge_stp_info[0].flags);

*/
	fclose(fp);
	return 0;
}

int getmacbyifname( char* bridgename,char * retmac)
{
        struct ifreq ifr;
        int fd;
        char tmpmac[6];
        bzero(&ifr, sizeof(ifr));
        strncpy(ifr.ifr_name, bridgename,16);
        fd=socket(PF_INET, SOCK_DGRAM,0 );
        if( fd < 0) {
                perror("socket()");
                return -1;
                }
        if (ioctl(fd, SIOCGIFHWADDR, &ifr) < 0) {
                perror("ioctl() get hardware address error:");
               	return -1;
                }

        else {
/*debug information  */
/*
        printf("Interface:%s Hardware Address:%02x:%02x:%02x:%02x:%02x:%02x \n",
        ifr.ifr_name,
	(unsigned char)ifr.ifr_hwaddr.sa_data[0],
	(unsigned char)ifr.ifr_hwaddr.sa_data[1],
	(unsigned char)ifr.ifr_hwaddr.sa_data[2],
	(unsigned char)ifr.ifr_hwaddr.sa_data[3],
	(unsigned char)ifr.ifr_hwaddr.sa_data[4],
	(unsigned char)ifr.ifr_hwaddr.sa_data[5]);
        }
        sprintf(tmpmac[6],"%02x:%02x:%02x:%02x:%02x:%02x",
        (unsigned char)ifr.ifr_hwaddr.sa_data[0],
	(unsigned char)ifr.ifr_hwaddr.sa_data[1],
	(unsigned char)ifr.ifr_hwaddr.sa_data[2],
	(unsigned char)ifr.ifr_hwaddr.sa_data[3],
	(unsigned char)ifr.ifr_hwaddr.sa_data[4],
	(unsigned char)ifr.ifr_hwaddr.sa_data[5]);
*/
	memcpy(retmac,ifr.ifr_hwaddr.sa_data,6);
//	fclose(fd);
	return 0;
        
	}
}

int setAgeingtime(int a)
{
	char tmp[128];
        sprintf(tmp,"brctl setageing br0 %d",a);
        return system( tmp );
	
}
int setBridgeHellotime(int t)
{
	char tmp[128];
	sprintf(tmp,"brctl sethello br0 %.2f",((float)t)/100);
	return system(tmp);
}

int SetStpPriority(int a){
	char tmp[256];
	sprintf(tmp,"brctl setbridgeprio br0 %d",a);
	return system(tmp);
}

int SetSptBridgeMaxAge(unsigned long  time){
	char tmp[256];
	sprintf(tmp,"brctl setmaxage  br0 %.2f",((float)time)/100);
	/* maybe we will formate the time */
	return system(tmp);
}

int SetStpBridgeHelloTime(unsigned long time)
{
	char tmp[256];
	sprintf(tmp,"brctl sethello br0 %.2f",((float)time)/100);
	/* maybe we will formate the time */
	return system(tmp);
}

int SetStpBridgeForwardDelay(unsigned long time)
{
	char tmp[256];
	sprintf(tmp,"brctl setfd  br0 %.2f",((float)time)/100);
	/* maybe we will formate the time */
	return system(tmp);
}

int SetStpPortPriority(int a){

	/*
	maybe we will check the valid value
	a>0,a<255
	*/
	char tmp[256];
	sprintf(tmp,"brctl setportprio  br0 %i",a);
	/* maybe we will formate the time */
	return system(tmp);
	
}
