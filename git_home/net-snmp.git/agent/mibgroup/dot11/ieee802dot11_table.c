/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.iterate.conf,v 5.5.2.1 2003/07/02 17:36:07 hardaker Exp $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "ieee802dot11_table.h"

/** Initialize the dot11WEPKeyMappingsTable table by defining its contents and how it's structured */


/** Initialize the dot11PhyFHSSTable table by defining its contents and how it's structured */


/** Initialize the dot11PhyDSSSTable table by defining its contents and how it's structured */

typedef unsigned int 	MYINTEGER;
typedef unsigned long 	MYInteger32;
typedef unsigned int 	MYEnumVal;
typedef unsigned int 	MYCounter;
typedef int			MYIfIndex;

#ifdef NEED_BACKUP
static void *	backupBuf;
static int		valLen;
static int 		bufLen;

static int backup(const void* val,int len)//val in
{
	if(valLen!=0)
		return -1;
	if(len>bufLen)
	{
		if(backupBuf)
			free(backupBuf);
		if(!(backupBuf=malloc(len)))
		{
			bufLen=0;
			return 1;
		}
		bufLen=len;
	}
	memcpy(backupBuf,val,len);
	valLen=len;
	return 0;
}

static int restore(void* val,int len)
{
	if(len!=valLen || val==NULL)
		return -1;
	memcpy(val,backupBuf,valLen);
	valLen=0;
	return 0;
}

static int clear()
{
	//if(valLen==0)
	//	return -1;
	valLen=0;
	return 0;
}

#endif

typedef struct IfList_s {
	MYIfIndex		index;
	char		 name[64];
	struct IfList_s*	next;
}IfList_elem;


static IfList_elem* g_ifList;

static void initialize_interfase_list()
{
	
	IfList_elem *tmp,*tail;
	int i;
	FILE* fp;
	char ifName[10];
	int ifIndex=5;
	fp=fopen("/proc/net/dev","r");
	if(fp)
	{
		while(fgetc(fp)!='\n');
		for(ifIndex=1;ifIndex<5;++ifIndex)
		{
			while(fgetc(fp)!='\n');
			fscanf(fp,"%4s",ifName);
			if(strcmp(ifName,"ath0")==0)
				break;
		}
		fclose(fp);
	}
	if(ifIndex==5)
		snmp_log(LOG_ERR,"get ifIndex fail");
        for(g_ifList=NULL,i=0;i<1;++i)
        {
                tmp=(IfList_elem*)malloc(sizeof(IfList_elem));
                if(tmp)
                {
                        tmp->index=ifIndex;
			strcpy(tmp->name,"ath0");
                        tmp->next=NULL;
                        if(g_ifList==NULL)
                        {
                                g_ifList=tmp;
                        }
                        else
                        {
                                tail->next=tmp;
                        }
                        tail=tmp;
                }
                else
                        break;
        }
}

/** Initializes the ieee802dot11_table module */

static char g_mac[6];

static int hex2dec(char c)
{
        if(c>='0'&&c<='9')
                return c-'0';
        if(c>='A'&&c<='F')
                return c-'A'+10;
        if(c>='a'&&c<='f')
                return c-'a'+10;
        else
                return 0;
}
static void get_mac()
{
	FILE* fp;
	int i;
	system("ifconfig ath0>/tmp/data");
	fp=fopen("/tmp/data","r");
        if(fp)
        {
                fseek(fp,38L,SEEK_SET);
                for(i=0;i<6;++i)
                {
                        g_mac[i]=hex2dec(fgetc(fp));
                        g_mac[i]=16*g_mac[i] + hex2dec(fgetc(fp));
                        fgetc(fp);
                }
                fclose(fp);
        }
}
void
init_ieee802dot11_table(void)
{
#ifdef NEED_BACKUP
	bufLen=0;
	backupBuf=NULL;
	valLen=0;
#endif
	initialize_interfase_list();
	get_mac();

    /*
     * here we initialize all the tables we're planning on supporting 
     */
     	
	initialize_table_dot11StationConfigTable();			// 1.2.840.10036.1.1  
	
	 initialize_table_dot11AuthenticationAlgorithmsTable();		// 1.2.840.10036.1.2 

	 initialize_table_dot11WEPDefaultKeysTable();			// 1.2.840.10036.1.3 
	
//	 initialize_table_dot11WEPKeyMappingsTable();			// 1.2.840.10036.1.4  

 	 initialize_table_dot11PrivacyTable();				// 1.2.840.10036.1.5 

	 initialize_table_dot11OperationTable();				// 1.2.840.10036.2.1 
	
	 initialize_table_dot11CountersTable();				// 1.2.840.10036.2.2 

//	 initialize_table_dot11GroupAddressesTable();			// 1.2.840.10036.2.3 

	 initialize_table_dot11ResourceInfoTable();			// 1.2.840.10036.3.1.2 
		
	 initialize_table_dot11PhyOperationTable();			// 1.2.840.10036.4.1 
		
 	initialize_table_dot11PhyAntennaTable();			// 1.2.840.10036.4.2 

 	initialize_table_dot11PhyTxPowerTable();			// 1.2.840.10036.4.3 
	
//	 initialize_table_dot11PhyFHSSTable();				// 1.2.840.10036.4.4 
	
	 initialize_table_dot11PhyDSSSTable();				// 1.2.840.10036.4.5 
	
 //   initialize_table_dot11PhyIRTable();				// 1.2.840.10036.4.6 

	initialize_table_dot11RegDomainsSupportedTable();		// 1.2.840.10036.4.7 
    	
    	initialize_table_dot11AntennasListTable();			// 1.2.840.10036.4.8 
	
	initialize_table_dot11SupportedDataRatesTxTable();		// 1.2.840.10036.4.9 
	 
	initialize_table_dot11SupportedDataRatesRxTable();		// 1.2.840.10036.4.10

}

#define OPERATIONAL_RATE_SET_LEN	12

typedef struct dot11StationConfigTable_elem_s{
	MYIfIndex			ifIndex;
	struct dot11StationConfigTable_elem_s *next;
	char			stationID[6];
	MYINTEGER	mediumOccupancyLimit;
	MYEnumVal	cFPollable;
	MYINTEGER	cFPPeriod;
	MYINTEGER	cFPMaxDuration;
	MYINTEGER	authenticationResponseTimeOut;
	MYEnumVal	privacyOptionImplemented;
	MYEnumVal	powerManagementMode;
	//char			desiredSSID[1+sizeof("desiredSSID")]; dynamic
	//MYEnumVal	desiredBSSType;	dynamic;
	char			operationalRateSet[OPERATIONAL_RATE_SET_LEN];
	//MYINTEGER	beaconPeriod;	dynamic
	//MYINTEGER	dTIMPeriod;	dynamic
	MYINTEGER	associationResponseTimeOut;
	MYINTEGER	disassociateReason;
	char			disassociateStation[6];
	MYINTEGER	deauthenticateReason;
	char			deauthenticateStation[6];
	MYINTEGER	authenticateFailStatus;
	char			authenticateFailStation[6];
}dot11StationConfigTable_elem;

static dot11StationConfigTable_elem *dot11StationConfigTable;

void
initialize_table_dot11StationConfigTable(void)
{
	int i;
	char strVal[1];
	int  intVal;
	IfList_elem* ifList;
	dot11StationConfigTable_elem *p_elem, *tail;
	char rateSet[OPERATIONAL_RATE_SET_LEN]={0x82, 0x84, 0x8B, 0x8C, 0x12, 0x96, 0x98, 0x24, 0xB0, 0x48, 0x60, 0x6C};
	for(ifList=g_ifList, i=0,dot11StationConfigTable=NULL; ifList; ifList=ifList->next, ++i)
	{
		strVal[0]=i+1;
		intVal=i+1;
		p_elem=(dot11StationConfigTable_elem*)malloc(sizeof(dot11StationConfigTable_elem));
		if(p_elem)
		{
			p_elem->ifIndex=ifList->index;
			p_elem->next=NULL;
			memcpy(p_elem->stationID,g_mac,6);
			p_elem->mediumOccupancyLimit=0;	//?
			p_elem->cFPollable=2;		//?
			p_elem->cFPPeriod=0;		//?
			p_elem->cFPMaxDuration=0;	//?
			p_elem->authenticationResponseTimeOut=512;	//?
			p_elem->privacyOptionImplemented=1;
			p_elem->powerManagementMode=1;		//?
			//memcpy(p_elem->desiredSSID,strVal,1);
			//p_elem->desiredBSSType=intVal;
			memcpy(p_elem->operationalRateSet,rateSet,OPERATIONAL_RATE_SET_LEN); //?
			//p_elem->beaconPeriod=intVal;	//?
			//p_elem->dTIMPeriod=intVal;		//?
			p_elem->associationResponseTimeOut=500;	//?
			p_elem->disassociateReason=0;	//?			
			memset(p_elem->disassociateStation,0,6); //?
			p_elem->deauthenticateReason=0;	//?
			memset(p_elem->deauthenticateStation,0,6); //?
			p_elem->authenticateFailStatus=0;	//?
			memset(p_elem->authenticateFailStation,0,6);	//?
			if(dot11StationConfigTable==NULL)
				dot11StationConfigTable=p_elem;
			else
				tail->next=p_elem;
			tail=p_elem;
		}
		else
			break;
	}
    static oid      dot11StationConfigTable_oid[] =
        { 1, 2, 840, 10036, 1, 1 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /*
     * create the table structure itself 
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
     */
    my_handler =
        netsnmp_create_handler_registration("dot11StationConfigTable",
                                            dot11StationConfigTable_handler,
                                            dot11StationConfigTable_oid,
                                            OID_LENGTH
                                            (dot11StationConfigTable_oid),
                                            HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: ifIndex */
                                     0);

    table_info->min_column = 1;
    table_info->max_column = 20;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point =
        dot11StationConfigTable_get_first_data_point;
    iinfo->get_next_data_point =
        dot11StationConfigTable_get_next_data_point;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_dot11StationConfigTable",
                "Registering table dot11StationConfigTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}

netsnmp_variable_list *
dot11StationConfigTable_get_first_data_point(void **my_loop_context,
                                             void **my_data_context,
                                             netsnmp_variable_list *
                                             put_index_data,
                                             netsnmp_iterator_info *mydata)
{
	dot11StationConfigTable_elem *p_elem;
    	netsnmp_variable_list *vptr;
	p_elem=dot11StationConfigTable;
	if(!p_elem)
		return NULL;
	*my_loop_context = p_elem;
    	*my_data_context = p_elem;
	vptr = put_index_data;
	snmp_set_var_value(vptr, (u_char *) &p_elem->ifIndex,sizeof(MYIfIndex));
	return put_index_data;
}


netsnmp_variable_list *
dot11StationConfigTable_get_next_data_point(void **my_loop_context,
                                            void **my_data_context,
                                            netsnmp_variable_list *
                                            put_index_data,
                                            netsnmp_iterator_info *mydata)
{
	dot11StationConfigTable_elem *p_elem;
	p_elem=(dot11StationConfigTable_elem*)*my_loop_context;
	p_elem=p_elem->next;
	if(!p_elem)
		return NULL;
	*my_loop_context = p_elem ;
	*my_data_context = p_elem; 
	netsnmp_variable_list *vptr;
	vptr = put_index_data;
	snmp_set_var_value(vptr, (u_char *) &p_elem->ifIndex,sizeof(MYIfIndex));
                     
    return put_index_data;
}

/** handles requests for the dot11StationConfigTable table, if anything else needs to be done */
int
dot11StationConfigTable_handler(netsnmp_mib_handler *handler,
                                netsnmp_handler_registration *reginfo,
                                netsnmp_agent_request_info *reqinfo,
                                netsnmp_request_info *requests)
{
	dot11StationConfigTable_elem* p_elem;
	int i,c,rst;
	netsnmp_request_info *request;
	netsnmp_table_request_info *table_info;
	netsnmp_variable_list *var;
	FILE *fp;
	char ssid[33];
	MYEnumVal	desiredBSSType;
	MYINTEGER	value;
	char command[100];
    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed. 
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the dot11StationConfigTable table in question 
         */
         
         p_elem = ( dot11StationConfigTable_elem*)netsnmp_extract_iterator_context(request);
        if (p_elem == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
           
        }
	
        /*
         * extracts the information about the table from the request 
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested 
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request 
         */
        if (table_info == NULL) {
            continue;
        }
        switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here 
             */
            
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_DOT11STATIONID:
                snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                         (u_char *) p_elem->stationID, 6);
                break;

            case COLUMN_DOT11MEDIUMOCCUPANCYLIMIT:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &p_elem->mediumOccupancyLimit
                                         , sizeof(MYINTEGER) );
                break;

            case COLUMN_DOT11CFPOLLABLE:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &p_elem->cFPollable
                                         , sizeof(MYEnumVal) );
                break;

            case COLUMN_DOT11CFPPERIOD:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &p_elem->cFPPeriod
                                         , sizeof(MYINTEGER) );
                break;

            case COLUMN_DOT11CFPMAXDURATION:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *)&p_elem->cFPMaxDuration
                                         , sizeof(MYINTEGER) );
                break;

            case COLUMN_DOT11AUTHENTICATIONRESPONSETIMEOUT:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &p_elem->authenticationResponseTimeOut
                                         , sizeof(MYINTEGER));
                break;

            case COLUMN_DOT11PRIVACYOPTIONIMPLEMENTED:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &p_elem->privacyOptionImplemented
                                         , sizeof(MYEnumVal) );
                break;

            case COLUMN_DOT11POWERMANAGEMENTMODE:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &p_elem->powerManagementMode
                                         , sizeof(MYEnumVal) );
                break;

            case COLUMN_DOT11DESIREDSSID:
		system("/usr/bin/get_network_type>/tmp/data");
		fp=fopen("tmp/data","r");
		if(fp)
		{
			fscanf(fp,"%d",&value);
			fclose(fp);
			if(value==1)
			{
				system("/usr/bin/get_ssid >/tmp/data");
			}
			else
			{
				system("/usr/bin/get_ssid_select >/tmp/data");
				fp=fopen("/tmp/data","r");
				if(fp)
				{
					fscanf(fp,"%d",&value);
					fclose(fp);
					if(value==1)
						system("/usr/bin/get_status_essid >/tmp/data");
					else
						system("/usr/bin/get_ssid >/tmp/data");	
				}
			}
		}		
		fp=fopen("/tmp/data","r");
		if(fp)
		{
			for(i=0;(c=fgetc(fp))>0;++i)
				ssid[i]=c;
			if(i>0 && ssid[i-1]=='\n')
				ssid[i-1]=0;
			else
				ssid[i]=0;
			fclose(fp);
				
		}
                snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                         (u_char *) ssid, strlen(ssid));
                break;

            case COLUMN_DOT11DESIREDBSSTYPE:
		system("/usr/bin/get_network_type > /tmp/data");
		fp=fopen("/tmp/data","r");
		if(fp)
		{
			fscanf(fp,"%d",&desiredBSSType);
			fclose(fp);
			desiredBSSType+=1;
		}
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &desiredBSSType
                                         ,sizeof(MYEnumVal) );
                break;

            case COLUMN_DOT11OPERATIONALRATESET:
                snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                         (u_char *) p_elem->operationalRateSet
                                         , OPERATIONAL_RATE_SET_LEN );
                break;

            case COLUMN_DOT11BEACONPERIOD:
		system("/usr/bin/get_beacon >/tmp/data");
		fp=fopen("/tmp/data","r");
		if(fp)
		{
			if(fscanf(fp,"%d",&value)<0)
				value=0;
			fclose(fp);
		}
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &value , sizeof(MYINTEGER));
                break;

            case COLUMN_DOT11DTIMPERIOD:
		system("/usr/bin/get_dtim >/tmp/data");
                fp=fopen("/tmp/data","r");
                if(fp)
                {
                        if(fscanf(fp,"%d",&value)<0)
				value=0;
			fclose(fp);
                }
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &value,sizeof(MYINTEGER));
                break;

            case COLUMN_DOT11ASSOCIATIONRESPONSETIMEOUT:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &p_elem->associationResponseTimeOut
                                         , sizeof(MYINTEGER));
                break;

            case COLUMN_DOT11DISASSOCIATEREASON:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &p_elem->disassociateReason
                                         , sizeof(MYINTEGER) );
                break;

            case COLUMN_DOT11DISASSOCIATESTATION:
                snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                         (u_char *) p_elem->disassociateStation,6);
                break;

            case COLUMN_DOT11DEAUTHENTICATEREASON:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &p_elem->deauthenticateReason
                                         , sizeof(MYINTEGER) );
                break;

            case COLUMN_DOT11DEAUTHENTICATESTATION:
                snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                         (u_char *) p_elem->deauthenticateStation
                                         , sizeof(p_elem->deauthenticateStation));
                break;

            case COLUMN_DOT11AUTHENTICATEFAILSTATUS:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &p_elem->authenticateFailStatus
                                         ,sizeof(MYINTEGER));
                break;

            case COLUMN_DOT11AUTHENTICATEFAILSTATION:
                snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                         (u_char *) p_elem->authenticateFailStation
                                         , sizeof(p_elem->authenticateFailStation) );
                break;

            default:
                /*
                 * We shouldn't get here 
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in dot11StationConfigTable_handler: unknown column\n");
            }
            break;
        case MODE_SET_RESERVE1:
		switch (table_info->colnum) 
		{
		/*
		case COLUMN_DOT11STATIONID:
			
			if(var->type!=ASN_OCTET_STR)
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGTYPE);
			else if(var->val_len!=6)
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGLENGTH);
			else
				;
			break;
			
		case COLUMN_DOT11MEDIUMOCCUPANCYLIMIT:
			
			if(var->type!=ASN_INTEGER)
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGTYPE);
			else if(var->val_len!=sizeof(MYINTEGER))
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGLENGTH);
			else if(*var->val.integer<0 || *var->val.integer>1000)
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGVALUE);
			else
				;
			break;
		case COLUMN_DOT11CFPPERIOD:
			if(var->type!=ASN_INTEGER)
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGTYPE);
			else if(var->val_len!=sizeof(MYINTEGER))
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGLENGTH);
			else if(*var->val.integer<0 || *var->val.integer>255)
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGVALUE);
			else
				;
			break;
		case COLUMN_DOT11CFPMAXDURATION:
			if(var->type!=ASN_INTEGER)
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGTYPE);
			else if(var->val_len!=sizeof(MYINTEGER))
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGLENGTH);
			else if(*var->val.integer<0 || *var->val.integer>65535)
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGVALUE);
			else
				;
			break;
		case COLUMN_DOT11AUTHENTICATIONRESPONSETIMEOUT:
			if(var->type!=ASN_INTEGER)
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGTYPE);
			else if(var->val_len!=sizeof(MYINTEGER))
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGLENGTH);
			else if(*var->val.integer<0 || *var->val.integer>2147483647)
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGVALUE);
			else
				;
			break;
		case COLUMN_DOT11POWERMANAGEMENTMODE:
			if(var->type!=ASN_INTEGER)
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGTYPE);
			else if(var->val_len!=sizeof(MYEnumVal))
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGLENGTH);
			else if(*var->val.integer!=1 && *var->val.integer!=2)
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGVALUE);
			else
				;
			break;
		*/
		case COLUMN_DOT11DESIREDSSID:
			if(var->type!=ASN_OCTET_STR)
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGTYPE);
			else if(var->val_len<1 || var->val_len>32)
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGLENGTH);
			else
				;
			break;
		case COLUMN_DOT11DESIREDBSSTYPE:
			if(var->type!=ASN_INTEGER)
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGTYPE);
			else if(var->val_len!=sizeof(MYEnumVal))
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGLENGTH);
			else if(*var->val.integer!=1 && *var->val.integer!=2 && *var->val.integer!=3)
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGVALUE);
			else
				;
			break;
		/*
		case COLUMN_DOT11OPERATIONALRATESET:
			if(var->type!=ASN_OCTET_STR)
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGTYPE);
			else if(var->val_len>sizeof(p_elem->operationalRateSet))
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGLENGTH);
			else
				;
			break;
		*/
		case COLUMN_DOT11BEACONPERIOD:
			if(var->type!=ASN_INTEGER)
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGTYPE);
			else if(var->val_len!=sizeof(MYINTEGER)) 
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGLENGTH);
			else if(*var->val.integer<1 || *var->val.integer>65535)
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGVALUE);
			else
				;
			break;
		case COLUMN_DOT11DTIMPERIOD:
			if(var->type!=ASN_INTEGER)
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGTYPE);
			else if(var->val_len!=sizeof(MYINTEGER))
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGLENGTH);
			else if(*var->val.integer<1 || *var->val.integer>255)
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGVALUE);
			else
				;
			break;
		/*
		case COLUMN_DOT11ASSOCIATIONRESPONSETIMEOUT:
			if(var->type!=ASN_INTEGER)
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGTYPE);
			else if(var->val_len!=sizeof(MYINTEGER))
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGLENGTH);
			else if(*var->val.integer<1 || *var->val.integer>2147483647)
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGVALUE);
			else
				;
			break;
			*/
		default:
			netsnmp_set_request_error(reqinfo, request,SNMP_ERR_READONLY);//SNMP_ERR_NOTWRITABLE
			break;
		}
        	break;
	case MODE_SET_RESERVE2:
		/*
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11STATIONID:
			rst=backup( p_elem->stationID,6);
			break;
		case COLUMN_DOT11MEDIUMOCCUPANCYLIMIT:
			rst=backup(&p_elem->mediumOccupancyLimit
                                         , sizeof(p_elem->mediumOccupancyLimit));
			break;
		case COLUMN_DOT11CFPPERIOD:
			rst=backup(&p_elem->cFPPeriod
                                         , sizeof(p_elem->cFPPeriod));
			break;
		case COLUMN_DOT11CFPMAXDURATION:
			rst=backup(&p_elem->cFPMaxDuration
                                         , sizeof(p_elem->cFPMaxDuration) );
			break;
		case COLUMN_DOT11AUTHENTICATIONRESPONSETIMEOUT:
			rst=backup(&p_elem->authenticationResponseTimeOut
                                         , sizeof(p_elem->authenticationResponseTimeOut));
			break;
		case COLUMN_DOT11POWERMANAGEMENTMODE:
			rst=backup(&p_elem->powerManagementMode
                                         , sizeof(p_elem->powerManagementMode));
			break;
		case COLUMN_DOT11DESIREDSSID:
			rst=backup(p_elem->desiredSSID
                                         , sizeof(p_elem->desiredSSID));
			break;
		case COLUMN_DOT11DESIREDBSSTYPE:
			rst=backup(&p_elem->desiredBSSType
                                         ,sizeof(p_elem->desiredBSSType));
			break;
		case COLUMN_DOT11OPERATIONALRATESET:
			rst=backup(p_elem->operationalRateSet
                                         , sizeof(p_elem->operationalRateSet));
			break;
		case COLUMN_DOT11BEACONPERIOD:
			rst=backup(&p_elem->beaconPeriod
                                         , sizeof(p_elem->beaconPeriod));
			break;
		case COLUMN_DOT11DTIMPERIOD:
			rst=backup(&p_elem->dTIMPeriod
                                         , sizeof(p_elem->dTIMPeriod));
			break;
		case COLUMN_DOT11ASSOCIATIONRESPONSETIMEOUT:
			rst=backup(&p_elem->associationResponseTimeOut
                                         , sizeof(p_elem->associationResponseTimeOut));
			break;
		default:
			break;
		}
		if(rst)
			netsnmp_set_request_error(reqinfo, request,SNMP_ERR_GENERR);
			*/
		break;
	case MODE_SET_FREE:
		/*
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11STATIONID:
		case COLUMN_DOT11MEDIUMOCCUPANCYLIMIT:
		case COLUMN_DOT11CFPPERIOD:
		case COLUMN_DOT11CFPMAXDURATION:
		case COLUMN_DOT11AUTHENTICATIONRESPONSETIMEOUT:
		case COLUMN_DOT11POWERMANAGEMENTMODE:
		case COLUMN_DOT11DESIREDSSID:
		case COLUMN_DOT11DESIREDBSSTYPE:
		case COLUMN_DOT11OPERATIONALRATESET:
		case COLUMN_DOT11BEACONPERIOD:
		case COLUMN_DOT11DTIMPERIOD:
		case COLUMN_DOT11ASSOCIATIONRESPONSETIMEOUT:
			clear();
			break;
		default:
			break;
		}
		*/
		break;
	case MODE_SET_ACTION:
		
		switch (table_info->colnum) 
		{
		/*
		case COLUMN_DOT11STATIONID:
			memcpy(p_elem->stationID,var->val.string,6);
			break;
		case COLUMN_DOT11MEDIUMOCCUPANCYLIMIT:
			p_elem->mediumOccupancyLimit=*var->val.integer;
			break;
		case COLUMN_DOT11CFPPERIOD:
			p_elem->cFPPeriod=*var->val.integer;
			break;
		case COLUMN_DOT11CFPMAXDURATION:
			p_elem->cFPMaxDuration=*var->val.integer;
			break;
		case COLUMN_DOT11AUTHENTICATIONRESPONSETIMEOUT:
			p_elem->authenticationResponseTimeOut=*var->val.integer;
			break;
		case COLUMN_DOT11POWERMANAGEMENTMODE:
			p_elem->powerManagementMode=*var->val.integer;
			break;
		*/
		case COLUMN_DOT11DESIREDSSID:
			var->val.string[var->val_len]=0;
			sprintf(command,"usr/bin/set_ssid \"%s\"",var->val.string);
			system(command);

			system("/usr/bin/get_network_type>/tmp/data");
                        fp=fopen("tmp/data","r");
                        if(fp)
                        {
                                fscanf(fp,"%d",&value);
                                fclose(fp);
                                if(value==0)
                                {
                                        system("/usr/bin/cfgset --ssid_select 0");
                                }
				else
					system("/usr/bin/cfgset --network_type 1");
                        }
			break;
		case COLUMN_DOT11DESIREDBSSTYPE:
			if(*var->val.integer==3)
				break;
			sprintf(command,"/usr/bin/cfgset --network_type %d",*var->val.integer-1);
			system(command);
			break;
		/*
		case COLUMN_DOT11OPERATIONALRATESET:
			memcpy(p_elem->operationalRateSet,var->val.string,var->val_len);
			break;
		*/
		case COLUMN_DOT11BEACONPERIOD:
			sprintf(command,"/usr/bin/cfgset --beacon %d",*var->val.integer);
			system(command);
			break;
		case COLUMN_DOT11DTIMPERIOD:
			sprintf(command,"/usr/bin/cfgset --dtim %d",*var->val.integer);
			system(command);
			break;
		/*
		case COLUMN_DOT11ASSOCIATIONRESPONSETIMEOUT:
			p_elem->associationResponseTimeOut=*var->val.integer;
			break;
		*/
		default:
			break;
		}
		
		break;
	case MODE_SET_COMMIT:
		/*
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11STATIONID:
		case COLUMN_DOT11MEDIUMOCCUPANCYLIMIT:
		case COLUMN_DOT11CFPPERIOD:
		case COLUMN_DOT11CFPMAXDURATION:
		case COLUMN_DOT11AUTHENTICATIONRESPONSETIMEOUT:
		case COLUMN_DOT11POWERMANAGEMENTMODE:
		case COLUMN_DOT11DESIREDSSID:
		case COLUMN_DOT11DESIREDBSSTYPE:
		case COLUMN_DOT11OPERATIONALRATESET:
		case COLUMN_DOT11BEACONPERIOD:
		case COLUMN_DOT11DTIMPERIOD:
		case COLUMN_DOT11ASSOCIATIONRESPONSETIMEOUT:
			clear();
			break;
		default:
			break;
		}
		*/
		break;
	case MODE_SET_UNDO:
		/*
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11STATIONID:
			rst=restore( p_elem->stationID,6);
			break;
		case COLUMN_DOT11MEDIUMOCCUPANCYLIMIT:
			rst=restore(&p_elem->mediumOccupancyLimit
                                         , sizeof(p_elem->mediumOccupancyLimit));
			break;
		case COLUMN_DOT11CFPPERIOD:
			rst=restore(&p_elem->cFPPeriod
                                         , sizeof(p_elem->cFPPeriod));
			break;
		case COLUMN_DOT11CFPMAXDURATION:
			rst=restore(&p_elem->cFPMaxDuration
                                         , sizeof(p_elem->cFPMaxDuration));
			break;
		case COLUMN_DOT11AUTHENTICATIONRESPONSETIMEOUT:
			rst=restore(&p_elem->authenticationResponseTimeOut
                                         , sizeof(p_elem->authenticationResponseTimeOut));
			break;
		case COLUMN_DOT11POWERMANAGEMENTMODE:
			rst=restore(&p_elem->powerManagementMode
                                         , sizeof(p_elem->powerManagementMode));
			break;
		case COLUMN_DOT11DESIREDSSID:
			rst=restore(p_elem->desiredSSID
                                         , sizeof(p_elem->desiredSSID));
			break;
		case COLUMN_DOT11DESIREDBSSTYPE:
			rst=restore(&p_elem->desiredBSSType
                                         ,sizeof(p_elem->desiredBSSType));
			break;
		case COLUMN_DOT11OPERATIONALRATESET:
			rst=restore(p_elem->operationalRateSet
                                         , sizeof(p_elem->operationalRateSet));
			break;
		case COLUMN_DOT11BEACONPERIOD:
			rst=restore(&p_elem->beaconPeriod
                                         , sizeof(p_elem->beaconPeriod));
			break;
		case COLUMN_DOT11DTIMPERIOD:
			rst=restore(&p_elem->dTIMPeriod
                                         , sizeof(p_elem->dTIMPeriod));
			break;
		case COLUMN_DOT11ASSOCIATIONRESPONSETIMEOUT:
			rst=restore(&p_elem->associationResponseTimeOut
                                         , sizeof(p_elem->associationResponseTimeOut));
			break;
		default:
			break;
		}
		if(rst)
			netsnmp_set_request_error(reqinfo, request,SNMP_ERR_GENERR);
		*/
		break;
        default:
            snmp_log(LOG_ERR,
                     "problem encountered in dot11StationConfigTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}


typedef struct dot11AuthenticationAlgorithmsTable_elem_s{
	MYIfIndex		ifIndex;
	MYInteger32	authenticationAlgorithmsIndex;
	struct dot11AuthenticationAlgorithmsTable_elem_s *next;
	MYEnumVal	authenticationAlgorithm;
	//MYEnumVal	authenticationAlgorithmsEnable;
}dot11AuthenticationAlgorithmsTable_elem;

static dot11AuthenticationAlgorithmsTable_elem *dot11AuthenticationAlgorithmsTable;

void
initialize_table_dot11AuthenticationAlgorithmsTable(void)
{
	int i,j;
	char strVal[1];
	int  intVal;
	IfList_elem* ifList;
	dot11AuthenticationAlgorithmsTable_elem *p_elem, *tail;
	for(ifList=g_ifList, i=0,dot11AuthenticationAlgorithmsTable=NULL; ifList; ifList=ifList->next, ++i)
	{
		for(j=0;j<DOT11AUTHENTICATIONALGORITHMSTABLE_INDEX_MAX;++j)
		{
			p_elem=(dot11AuthenticationAlgorithmsTable_elem*)malloc(sizeof(dot11AuthenticationAlgorithmsTable_elem));
			if(p_elem)
			{
				p_elem->ifIndex=ifList->index;
				p_elem->authenticationAlgorithmsIndex=j+1;
				p_elem->next=NULL;
				p_elem->authenticationAlgorithm=j+1;
				//p_elem->authenticationAlgorithmsEnable=(i+1)*10+j+1; dynamic
				if(dot11AuthenticationAlgorithmsTable==NULL)
					dot11AuthenticationAlgorithmsTable=p_elem;
				else
					tail->next=p_elem;
				tail=p_elem;
			}
			else
			{
				ifList=NULL;
				break;
			}
			
		}
	}
    static oid      dot11AuthenticationAlgorithmsTable_oid[] =
        { 1, 2, 840, 10036, 1, 2 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /*
     * create the table structure itself 
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
     */
    my_handler = netsnmp_create_handler_registration
        ("dot11AuthenticationAlgorithmsTable",
         dot11AuthenticationAlgorithmsTable_handler,
         dot11AuthenticationAlgorithmsTable_oid,
         OID_LENGTH(dot11AuthenticationAlgorithmsTable_oid),
         HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: ifIndex */
                                     ASN_INTEGER,       /* index: dot11AuthenticationAlgorithmsIndex */
                                     0);

    table_info->min_column = 2;
    table_info->max_column = 3;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point =
        dot11AuthenticationAlgorithmsTable_get_first_data_point;
    iinfo->get_next_data_point =
        dot11AuthenticationAlgorithmsTable_get_next_data_point;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_dot11AuthenticationAlgorithmsTable",
                "Registering table dot11AuthenticationAlgorithmsTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}


netsnmp_variable_list *
dot11AuthenticationAlgorithmsTable_get_first_data_point(void**my_loop_context,
                                                        void**my_data_context,
                                                        netsnmp_variable_list* put_index_data,
                                                        netsnmp_iterator_info *mydata)
{
	dot11AuthenticationAlgorithmsTable_elem *p_elem;
	netsnmp_variable_list *vptr;
	p_elem=dot11AuthenticationAlgorithmsTable;
	if(!p_elem)
		return NULL;
	*my_loop_context = p_elem ;
	*my_data_context = p_elem ;

	vptr = put_index_data;

	snmp_set_var_value(vptr, (u_char *) &p_elem->ifIndex,sizeof(MYIfIndex));
	vptr = vptr->next_variable;
	snmp_set_var_value(vptr,(u_char*)&p_elem->authenticationAlgorithmsIndex,sizeof(MYInteger32));

    return put_index_data;
}



netsnmp_variable_list *
dot11AuthenticationAlgorithmsTable_get_next_data_point(void**my_loop_context,
                                                       void**my_data_context,
                                                       netsnmp_variable_list *put_index_data,
                                                       netsnmp_iterator_info *mydata)
{
	dot11AuthenticationAlgorithmsTable_elem *p_elem;
	netsnmp_variable_list *vptr;
	p_elem=(dot11AuthenticationAlgorithmsTable_elem*)*my_loop_context;
	p_elem=p_elem->next;
	if(!p_elem)
		return NULL;


 	*my_loop_context = p_elem;
 	*my_data_context = p_elem;
	vptr = put_index_data;
	snmp_set_var_value(vptr, (u_char *) &p_elem->ifIndex,sizeof(MYIfIndex));
	vptr = vptr->next_variable;
	snmp_set_var_value(vptr,(u_char*)&p_elem->authenticationAlgorithmsIndex,sizeof(MYInteger32));

    return put_index_data;
}

/** handles requests for the dot11AuthenticationAlgorithmsTable table, if anything else needs to be done */
int
dot11AuthenticationAlgorithmsTable_handler(netsnmp_mib_handler *handler,
                                           netsnmp_handler_registration
                                           *reginfo,
                                           netsnmp_agent_request_info
                                           *reqinfo,
                                           netsnmp_request_info *requests)
{
	dot11AuthenticationAlgorithmsTable_elem *p_elem;
    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
	FILE *fp;
	char command[50];
	char c;
	int n,mode;
	MYEnumVal authenticationAlgorithmsEnable;
	
    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed. 
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the dot11AuthenticationAlgorithmsTable table in question 
         */

         p_elem = (dot11AuthenticationAlgorithmsTable_elem *)netsnmp_extract_iterator_context(request);
        if (p_elem == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            
        }

        /*
         * extracts the information about the table from the request 
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested 
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request 
         */
        if (table_info == NULL) {
            continue;
        }
        switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here 
             */

        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_DOT11AUTHENTICATIONALGORITHM:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *)&p_elem->authenticationAlgorithm
                                         , sizeof(MYEnumVal));
                break;

            case COLUMN_DOT11AUTHENTICATIONALGORITHMSENABLE:
		system("/usr/bin/get_security_mode>/tmp/data");
                fp=fopen("/tmp/data","r");
		if(fp)
		{
			mode=fgetc(fp);
			fclose(fp);
		}
		if(mode=='1')
		{
			system("/usr/bin/get_wep_shared_key>/tmp/data");
			fp=fopen("/tmp/data","r");
			if(fp)
			{
			
				fscanf(fp,"%d",&n);
				fclose(fp);
				if(p_elem->authenticationAlgorithmsIndex==1)
					authenticationAlgorithmsEnable= (n==0)?1:2;
				else
					authenticationAlgorithmsEnable= (n==1)?1:2;
			}
		}
		else
			authenticationAlgorithmsEnable=1;
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *)&authenticationAlgorithmsEnable
                                         , sizeof(MYEnumVal));
                break;

            default:
                /*
                 * We shouldn't get here 
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in dot11AuthenticationAlgorithmsTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11AUTHENTICATIONALGORITHMSENABLE:
			if(var->type!=ASN_INTEGER)
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGTYPE);
			else if(var->val_len!=sizeof(MYEnumVal))
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGLENGTH);
			else if(*var->val.integer!=1 && *var->val.integer!=2)
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGVALUE);
			else
				;
			break;
		default:
			netsnmp_set_request_error(reqinfo, request,SNMP_ERR_READONLY);
			break;
		}
        	break;
	case MODE_SET_RESERVE2:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11AUTHENTICATIONALGORITHMSENABLE:
			break;
		default:
			break;
		}
		break;
	case MODE_SET_FREE:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11AUTHENTICATIONALGORITHMSENABLE:
			break;
		default:
			break;
		}
		break;
	case MODE_SET_ACTION:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11AUTHENTICATIONALGORITHMSENABLE:
			system("/usr/bin/get_security_mode>/tmp/data");
                	fp=fopen("/tmp/data","r");
                	if(fp)
                	{
                        	mode=fgetc(fp);
                        	fclose(fp);
                	}
                	if(mode=='1')
			{
				if(p_elem->authenticationAlgorithmsIndex==1)
					n= (*var->val.integer==1)?0:1;
				else
					n= (*var->val.integer==1)?1:0;
				sprintf(command,"/usr/bin/cfgset --wep_shared_key %d",n);
				system(command);
			}
			break;
		default:
			break;
		}
		break;
	case MODE_SET_COMMIT:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11AUTHENTICATIONALGORITHMSENABLE:
			break;
		default:
			break;
		}
		break;
	case MODE_SET_UNDO:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11AUTHENTICATIONALGORITHMSENABLE:
			break;
		default:
			break;
		}
		break;
        default:
            snmp_log(LOG_ERR,
                     "problem encountered in dot11AuthenticationAlgorithmsTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}


typedef struct dot11WEPDefaultKeysTable_elem_s
{
	MYIfIndex		ifIndex;
	MYINTEGER	WEPDefaultKeyIndex;
	struct dot11WEPDefaultKeysTable_elem_s *next;
//	char WEPDefaultKeyValue[5];
}dot11WEPDefaultKeysTable_elem;

static dot11WEPDefaultKeysTable_elem	*dot11WEPDefaultKeysTable;

void
initialize_table_dot11WEPDefaultKeysTable(void)
{
	int i,j;
	char strVal[2];
	IfList_elem* ifList;
	dot11WEPDefaultKeysTable_elem *p_elem, *tail;
	for(ifList=g_ifList, i=0,dot11WEPDefaultKeysTable=NULL; ifList; ifList=ifList->next, ++i)
	{
		for(j=0;j<DOT11WEPDEFAULTKEYSTABLE_INDEX_MAX;++j)
		{
			strVal[0]=i+1;strVal[1]=j+1;
			p_elem=(dot11WEPDefaultKeysTable_elem*)malloc(sizeof(dot11WEPDefaultKeysTable_elem));
			if(p_elem)
			{
				p_elem->ifIndex=ifList->index;
				p_elem->WEPDefaultKeyIndex=j+1;
				p_elem->next=NULL;
				//memcpy(p_elem->WEPDefaultKeyValue,strVal,2); dynamic
				if(dot11WEPDefaultKeysTable==NULL)
					dot11WEPDefaultKeysTable=p_elem;
				else
					tail->next=p_elem;
				tail=p_elem;
			}
			else
			{
				ifList=NULL;
				break;
			}
		}
	}
    static oid      dot11WEPDefaultKeysTable_oid[] =
        { 1, 2, 840, 10036, 1, 3 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /*
     * create the table structure itself 
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
     */
    my_handler =
        netsnmp_create_handler_registration("dot11WEPDefaultKeysTable",
                                            dot11WEPDefaultKeysTable_handler,
                                            dot11WEPDefaultKeysTable_oid,
                                            OID_LENGTH
                                            (dot11WEPDefaultKeysTable_oid),
                                            HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: ifIndex */
                                     ASN_INTEGER,       /* index: dot11WEPDefaultKeyIndex */
                                     0);

    table_info->min_column = 2;
    table_info->max_column = 2;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point =
        dot11WEPDefaultKeysTable_get_first_data_point;
    iinfo->get_next_data_point =
        dot11WEPDefaultKeysTable_get_next_data_point;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_dot11WEPDefaultKeysTable",
                "Registering table dot11WEPDefaultKeysTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}



netsnmp_variable_list *
dot11WEPDefaultKeysTable_get_first_data_point(void **my_loop_context,
                                              void **my_data_context,
                                              netsnmp_variable_list *
                                              put_index_data,
                                              netsnmp_iterator_info
                                              *mydata)
{
	dot11WEPDefaultKeysTable_elem *p_elem;
	p_elem=dot11WEPDefaultKeysTable;
	if(!p_elem)
		return NULL;
	
	*my_loop_context = p_elem ;
	*my_data_context = p_elem ;

	netsnmp_variable_list *vptr;
	vptr = put_index_data;

	snmp_set_var_value(vptr, (u_char *) &p_elem->ifIndex,sizeof(MYIfIndex));
	vptr = vptr->next_variable;
	snmp_set_var_value(vptr,(u_char *) &p_elem->WEPDefaultKeyIndex,sizeof(MYINTEGER));

    return put_index_data;
}



netsnmp_variable_list *
dot11WEPDefaultKeysTable_get_next_data_point(void **my_loop_context,
                                             void **my_data_context,
                                             netsnmp_variable_list *
                                             put_index_data,
                                             netsnmp_iterator_info *mydata)
{
	dot11WEPDefaultKeysTable_elem *p_elem;
	p_elem=(dot11WEPDefaultKeysTable_elem*)*my_loop_context;
	p_elem=p_elem->next;
	if(!p_elem)
		return NULL;


	*my_loop_context = p_elem ;
	*my_data_context = p_elem ;

	netsnmp_variable_list *vptr;
	vptr = put_index_data;

	snmp_set_var_value(vptr, (u_char *) &p_elem->ifIndex,sizeof(MYIfIndex));
	vptr = vptr->next_variable;
	snmp_set_var_value(vptr,(u_char *) &p_elem->WEPDefaultKeyIndex,sizeof(MYINTEGER));

    return put_index_data;
}

/** handles requests for the dot11WEPDefaultKeysTable table, if anything else needs to be done */
int
dot11WEPDefaultKeysTable_handler(netsnmp_mib_handler *handler,
                                 netsnmp_handler_registration *reginfo,
                                 netsnmp_agent_request_info *reqinfo,
                                 netsnmp_request_info *requests)
{
	dot11WEPDefaultKeysTable_elem *p_elem;
    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
	FILE* fp;
	char	command[100];
	char key[40];
	int i,j,len;
    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed. 
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the dot11WEPDefaultKeysTable table in question 
         */
        /*
         * XXX 
         */
        
         p_elem = ( dot11WEPDefaultKeysTable_elem*)netsnmp_extract_iterator_context(request);
        if (  p_elem == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            
        }
	
        /*
         * extracts the information about the table from the request 
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested 
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request 
         */
        if (table_info == NULL) {
            continue;
        }
        switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here 
             */
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_DOT11WEPDEFAULTKEYVALUE:
                snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                         (u_char *) key,0);
                break;

            default:
                snmp_log(LOG_ERR,
                         "problem encountered in dot11WEPDefaultKeysTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11WEPDEFAULTKEYVALUE:
			if(var->type!=ASN_OCTET_STR)
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGTYPE);
			else if(var->val_len!=5)
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGLENGTH);
			else
				;
			break;
		default:
			netsnmp_set_request_error(reqinfo, request,SNMP_ERR_READONLY);
			break;
		}
        	break;
	case MODE_SET_RESERVE2:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11WEPDEFAULTKEYVALUE:
			break;
		default:
			break;
		}
		break;
	case MODE_SET_FREE:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11WEPDEFAULTKEYVALUE:
			break;
		default:
			break;
		}
		break;
	case MODE_SET_ACTION:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11WEPDEFAULTKEYVALUE:
			break;
		default:
			break;
		}
		break;
	case MODE_SET_COMMIT:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11WEPDEFAULTKEYVALUE:
			break;
		default:
			break;
		}
		break;
	case MODE_SET_UNDO:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11WEPDEFAULTKEYVALUE:
			break;
		default:
			break;
		}
		break;
        default:
            snmp_log(LOG_ERR,
                     "problem encountered in dot11WEPDefaultKeysTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}

#if 0

typedef struct dot11WEPKeyMappingsTable_elem_s{
	MYIfIndex		ifIndex;
	MYInteger32	WEPKeyMappingIndex;
	struct dot11WEPKeyMappingsTable_elem_s *next;
	char	addr[6];
	MYEnumVal isOn;
	char value[5];
	MYEnumVal status;
}dot11WEPKeyMappingsTable_elem;

static dot11WEPKeyMappingsTable_elem *dot11WEPKeyMappingsTable;

void
initialize_table_dot11WEPKeyMappingsTable(void)
{

	int i,j;
	int intVal;
	char strVal[2];
	IfList_elem* ifList;
	dot11WEPKeyMappingsTable_elem *p_elem, *tail;
	for(ifList=g_ifList, i=0,dot11WEPKeyMappingsTable=NULL; ifList; ifList=ifList->next, ++i)
	{
		for(j=DOT11WEPKEYMAPPINGSTABLE_INDEX_MIN-1;j<DOT11WEPKEYMAPPINGSTABLE_INDEX_MAX;++j)
		{
			intVal=(i+1)*10+j+1;
			strVal[0]=i+1;strVal[1]=j+1;
			p_elem=(dot11WEPKeyMappingsTable_elem*)malloc(sizeof(dot11WEPKeyMappingsTable_elem));
			if(p_elem)
			{
				p_elem->ifIndex=ifList->index;
				p_elem->WEPKeyMappingIndex=j+1;
				p_elem->next=NULL;
				memcpy(p_elem->addr,strVal,2);
				p_elem->isOn=intVal;
				memcpy(p_elem->value,strVal,2);
				p_elem->status=intVal;
				if(dot11WEPKeyMappingsTable==NULL)
					dot11WEPKeyMappingsTable=p_elem;
				else
					tail->next=p_elem;
				tail=p_elem;
			}
			else
			{
				ifList=NULL;
				break;
			}
		}
	}
    static oid      dot11WEPKeyMappingsTable_oid[] ={ 1, 2, 840, 10036, 1, 4 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /*
     * create the table structure itself 
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
     */
    my_handler =
        netsnmp_create_handler_registration("dot11WEPKeyMappingsTable",
                                            dot11WEPKeyMappingsTable_handler,
                                            dot11WEPKeyMappingsTable_oid,
                                            OID_LENGTH
                                            (dot11WEPKeyMappingsTable_oid),
                                            HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: ifIndex */
                                     ASN_INTEGER,       /* index: dot11WEPKeyMappingIndex */
                                     0);

    table_info->min_column = 2;
    table_info->max_column = 5;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point =
        dot11WEPKeyMappingsTable_get_first_data_point;
    iinfo->get_next_data_point =
        dot11WEPKeyMappingsTable_get_next_data_point;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_dot11WEPKeyMappingsTable",
                "Registering table dot11WEPKeyMappingsTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}



netsnmp_variable_list *
dot11WEPKeyMappingsTable_get_first_data_point(void **my_loop_context,
                                              void **my_data_context,
                                              netsnmp_variable_list *
                                              put_index_data,
                                              netsnmp_iterator_info
                                              *mydata)
{
	dot11WEPKeyMappingsTable_elem *p_elem;
	p_elem=dot11WEPKeyMappingsTable;
	if(!p_elem)
		return NULL;
	*my_loop_context = p_elem;
	*my_data_context = p_elem ;
	
    	netsnmp_variable_list *vptr;    
	vptr = put_index_data;

	snmp_set_var_value(vptr, (u_char *)&p_elem->ifIndex,sizeof(MYIfIndex));
	 vptr = vptr->next_variable;
	snmp_set_var_value(vptr, (u_char *)&p_elem->WEPKeyMappingIndex,sizeof(MYInteger32));
	return put_index_data;
}

netsnmp_variable_list *
dot11WEPKeyMappingsTable_get_next_data_point(void **my_loop_context,
                                             void **my_data_context,
                                             netsnmp_variable_list *
                                             put_index_data,
                                             netsnmp_iterator_info *mydata)
{
	dot11WEPKeyMappingsTable_elem *p_elem;
	p_elem=(dot11WEPKeyMappingsTable_elem*)*my_loop_context;
	p_elem=p_elem->next;
	if(!p_elem)
		return NULL;
	*my_loop_context = p_elem;
	*my_data_context = p_elem ;
	
	netsnmp_variable_list *vptr;    
	vptr = put_index_data;

	snmp_set_var_value(vptr, (u_char *)&p_elem->ifIndex,sizeof(MYIfIndex));
	 vptr = vptr->next_variable;
	snmp_set_var_value(vptr, (u_char *)&p_elem->WEPKeyMappingIndex,sizeof(MYInteger32));
	return put_index_data;
}

/** handles requests for the dot11WEPKeyMappingsTable table, if anything else needs to be done */
int
dot11WEPKeyMappingsTable_handler(netsnmp_mib_handler *handler,
                                 netsnmp_handler_registration *reginfo,
                                 netsnmp_agent_request_info *reqinfo,
                                 netsnmp_request_info *requests)
{
	dot11WEPKeyMappingsTable_elem *p_elem;
    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed. 
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the dot11WEPKeyMappingsTable table in question 
         */
         
	p_elem  = (dot11WEPKeyMappingsTable_elem *)netsnmp_extract_iterator_context(request);
	if (p_elem == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }

        }
        

        /*
         * extracts the information about the table from the request 
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested 
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request 
         */
        if (table_info == NULL) {
            continue;
        }
        switch (reqinfo->mode) {
          
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_DOT11WEPKEYMAPPINGADDRESS:
                snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                         (u_char *) p_elem->addr, 6 );
                break;

            case COLUMN_DOT11WEPKEYMAPPINGWEPON:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &p_elem->isOn,
                                         sizeof(MYEnumVal));
                                         
                break;

            case COLUMN_DOT11WEPKEYMAPPINGVALUE:
                snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                         (u_char *) p_elem->value,5);
                break;

            case COLUMN_DOT11WEPKEYMAPPINGSTATUS:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &p_elem->status,
                                         sizeof(MYEnumVal));
                                         
                break;

            default:
                /*
                 * We shouldn't get here 
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in dot11WEPKeyMappingsTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
        	netsnmp_set_request_error(reqinfo, request,SNMP_ERR_READONLY);
		break;
	case MODE_SET_FREE:
		break;
        default:
            snmp_log(LOG_ERR,
                     "problem encountered in dot11WEPKeyMappingsTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}

#endif

typedef struct dot11PrivacyTable_elem_s{
	MYIfIndex		ifIndex;
	struct dot11PrivacyTable_elem_s*	next;
	//MYEnumVal	privacyInvoked;		dynamic
	//MYINTEGER	WEPDefaultKeyID;		dynamic
	MYINTEGER	WEPKeyMappingLength;
	//MYEnumVal	excludeUnencrypted;		dynamic
	//MYCounter	WEPICVErrorCount;		dynamic
	//MYCounter	WEPExcludedCount;	dynamic
}dot11PrivacyTable_elem;

static dot11PrivacyTable_elem	*dot11PrivacyTable;

void
initialize_table_dot11PrivacyTable(void)
{
	int i;
	IfList_elem* ifList;
	dot11PrivacyTable_elem *p_elem, *tail;
	for(ifList=g_ifList, i=0,dot11PrivacyTable=NULL; ifList; ifList=ifList->next, ++i)
	{
		p_elem=(dot11PrivacyTable_elem*)malloc(sizeof(dot11PrivacyTable_elem));
		if(p_elem)
		{
			p_elem->ifIndex=ifList->index;
			p_elem->next=NULL;
			//p_elem->privacyInvoked=i+1;
			//p_elem->WEPDefaultKeyID=i+1;
			p_elem->WEPKeyMappingLength=0;
			//p_elem->excludeUnencrypted=i+1;
			//p_elem->WEPICVErrorCount=i+1;
			//p_elem->WEPExcludedCount=i+1;
			if(dot11PrivacyTable==NULL)
				dot11PrivacyTable=p_elem;
			else
				tail->next=p_elem;
			tail=p_elem;
			
		}
		else
			break;
	}
    static oid      dot11PrivacyTable_oid[] = { 1, 2, 840, 10036, 1, 5 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /*
     * create the table structure itself 
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
     */
    my_handler = netsnmp_create_handler_registration("dot11PrivacyTable",
                                                     dot11PrivacyTable_handler,
                                                     dot11PrivacyTable_oid,
                                                     OID_LENGTH
                                                     (dot11PrivacyTable_oid),
                                                     HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: ifIndex */
                                     0);

    table_info->min_column = 1;
    table_info->max_column = 6;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point = dot11PrivacyTable_get_first_data_point;
    iinfo->get_next_data_point = dot11PrivacyTable_get_next_data_point;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_dot11PrivacyTable",
                "Registering table dot11PrivacyTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}


netsnmp_variable_list *
dot11PrivacyTable_get_first_data_point(void **my_loop_context,
                                       void **my_data_context,
                                       netsnmp_variable_list *
                                       put_index_data,
                                       netsnmp_iterator_info *mydata)
{
	dot11PrivacyTable_elem *p_elem;
	p_elem=dot11PrivacyTable;
	if(!p_elem)
		return NULL;

	*my_loop_context = p_elem;
	*my_data_context = p_elem ;
	
	netsnmp_variable_list *vptr;
	vptr = put_index_data;
	snmp_set_var_value(vptr, (u_char *) &p_elem->ifIndex,sizeof(MYIfIndex));

    return put_index_data;
}


netsnmp_variable_list *
dot11PrivacyTable_get_next_data_point(void **my_loop_context,
                                      void **my_data_context,
                                      netsnmp_variable_list *
                                      put_index_data,
                                      netsnmp_iterator_info *mydata)
{
	dot11PrivacyTable_elem *p_elem;
	p_elem=(dot11PrivacyTable_elem*)*my_loop_context;
	p_elem=p_elem->next;
	if(!p_elem)
		return NULL;

	*my_loop_context = p_elem ;
	*my_data_context = p_elem ;
	
	netsnmp_variable_list *vptr;
	vptr = put_index_data;
	snmp_set_var_value(vptr, (u_char *) &p_elem->ifIndex,sizeof(MYIfIndex));

    return put_index_data;
}

/** handles requests for the dot11PrivacyTable table, if anything else needs to be done */
int
dot11PrivacyTable_handler(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
	dot11PrivacyTable_elem *p_elem;
	int rst;
    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
	FILE *fp;
	char command[50];
	char c;
	int mode;
	MYEnumVal	privacyInvoked;
	MYINTEGER	WEPDefaultKeyID;
	MYEnumVal	excludeUnencrypted;
	MYCounter	WEPICVErrorCount;
	MYCounter	WEPExcludedCount;

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed. 
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the dot11PrivacyTable table in question 
         */

         p_elem = (dot11PrivacyTable_elem *)netsnmp_extract_iterator_context(request);
        if(p_elem == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            
        }

        /*
         * extracts the information about the table from the request 
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested 
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request 
         */
        if (table_info == NULL) {
            continue;
        }

        switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here 
             */
           
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_DOT11PRIVACYINVOKED:
		system("/usr/bin/get_security_mode>/tmp/data");
                fp=fopen("/tmp/data","r");
                if(fp)
                {
                	mode=fgetc(fp);
                        fclose(fp);
                }
                privacyInvoked=(mode=='1')?1:2;
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &privacyInvoked , sizeof(MYEnumVal) );
                break;

            case COLUMN_DOT11WEPDEFAULTKEYID:
		system("/usr/bin/get_wep_key_no>/tmp/data");
		fp=fopen("/tmp/data","r");
		if(fp)
		{
			fscanf(fp,"%d",&WEPDefaultKeyID);
			fclose(fp);
		}
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &WEPDefaultKeyID , sizeof(MYINTEGER) );
                break;

            case COLUMN_DOT11WEPKEYMAPPINGLENGTH:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *)&p_elem->WEPKeyMappingLength , sizeof(MYINTEGER) );
                break;

            case COLUMN_DOT11EXCLUDEUNENCRYPTED:
		system("iwpriv ath0 get_dropunencry>/tmp/data");
		fp=fopen("/tmp/data","r");
		if(fp)
		{
			fseek(fp,-4L,SEEK_END);
			c=fgetc(fp);
			excludeUnencrypted= (c=='1')?1:2;
			fclose(fp);
		}
				
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *)&excludeUnencrypted
                                         , sizeof(MYINTEGER) );
                break;

            case COLUMN_DOT11WEPICVERRORCOUNT:
		fp=fopen("/proc/sys/dev/ath0/wepicverrorcount","r");
		if(fp)
		{
			fscanf(fp,"%d",&WEPICVErrorCount);
			fclose(fp);
		}
		else
			printf("snmp need /proc/sys/dev/ath0/wepicverrorcount\n");
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *) &WEPICVErrorCount
                                         , sizeof(MYCounter) );
                break;

            case COLUMN_DOT11WEPEXCLUDEDCOUNT:
		fp=fopen("/proc/sys/dev/ath0/wepexcludedcount","r");
		if(fp)
		{
			fscanf(fp,"%d",&WEPExcludedCount);
			fclose(fp);
		}
		else
			printf("snmp need /proc/sys/dev/ath0/wepexcludedcount\n");
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *) &WEPExcludedCount
                                         , sizeof(MYCounter) );
                break;

            default:
                /*
                 * We shouldn't get here 
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in dot11PrivacyTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11PRIVACYINVOKED:
			if(var->type!=ASN_INTEGER)
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGTYPE);
			else if(var->val_len!=sizeof(MYEnumVal))
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGLENGTH);
			else if(*var->val.integer!=1 && *var->val.integer!=2)
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGVALUE);
			else
				;
			break;
		case COLUMN_DOT11WEPDEFAULTKEYID:
			if(var->type!=ASN_INTEGER)
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGTYPE);
			else if(var->val_len!=sizeof(MYINTEGER))
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGLENGTH);
			else if(*var->val.integer<1 || *var->val.integer>4)
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGVALUE);
			else
				;
			break;
/*
		case COLUMN_DOT11WEPKEYMAPPINGLENGTH:
			if(var->type!=ASN_INTEGER)
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGTYPE);
			else if(var->val_len!=sizeof(MYINTEGER))
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGLENGTH);
			else if(*var->val.integer<10 && *var->val.integer>2147483647)
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGVALUE);
			else
				;
			break;
*/
		case COLUMN_DOT11EXCLUDEUNENCRYPTED:
			if(var->type!=ASN_INTEGER)
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGTYPE);
			else if(var->val_len!=sizeof(MYEnumVal))
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGLENGTH);
			else if(*var->val.integer!=1 && *var->val.integer!=2)
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGVALUE);
			else
				;
			break;
		default:
			netsnmp_set_request_error(reqinfo, request,SNMP_ERR_READONLY);
			break;
		}
        	break;
	case MODE_SET_RESERVE2:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11PRIVACYINVOKED:
			break;
		case COLUMN_DOT11WEPDEFAULTKEYID:
			break;
		case COLUMN_DOT11WEPKEYMAPPINGLENGTH:
			break;
		case COLUMN_DOT11EXCLUDEUNENCRYPTED:
			break;
		default:
			break;
		}
		break;
	case MODE_SET_FREE:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11PRIVACYINVOKED:
		case COLUMN_DOT11WEPDEFAULTKEYID:
		case COLUMN_DOT11WEPKEYMAPPINGLENGTH:
		case COLUMN_DOT11EXCLUDEUNENCRYPTED:
			break;
		default:
			break;
		}
		break;
	case MODE_SET_ACTION:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11PRIVACYINVOKED:
			sprintf(command,"/usr/bin/cfgset --security_mode %d", (*var->val.integer==1)?1:0);
			system(command);
			break;
		case COLUMN_DOT11WEPDEFAULTKEYID:
			system("/usr/bin/get_security_mode>/tmp/data"); 
			fp=fopen("/tmp/data","r"); 
			if(fp) 
			{ 
				mode=fgetc(fp); 
				fclose(fp); 
				if(mode!='1') 
					break; 
			}
			sprintf(command,"/usr/bin/get_wep_key%d >/tmp/data",*var->val.integer);
			fp=fopen("/tmp/data","r");
			if(fp)
			{
				if(fgetc(fp)<0)
				{
					fclose(fp);
					break;
				}
				fclose(fp);
			}
			sprintf(command,"/usr/bin/cfgset --wep_key_no %d", *var->val.integer);
			system(command);
			break;
		/*
		case COLUMN_DOT11WEPKEYMAPPINGLENGTH:
			p_elem->WEPKeyMappingLength=*var->val.integer;
			break;
		*/
		case COLUMN_DOT11EXCLUDEUNENCRYPTED:
			sprintf(command,"iwpriv ath0 dropunencrypted %d", (*var->val.integer==1)?1:0);
			system(command);			
			break;
		default:
			break;
		}
		break;
	case MODE_SET_COMMIT:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11PRIVACYINVOKED:
		case COLUMN_DOT11WEPDEFAULTKEYID:
		//case COLUMN_DOT11WEPKEYMAPPINGLENGTH:
		case COLUMN_DOT11EXCLUDEUNENCRYPTED:
		//	clear();
			break;
		default:
			break;
		}
		break;
	case MODE_SET_UNDO:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11PRIVACYINVOKED:
		//	rst=restore(&p_elem->privacyInvoked,sizeof(MYEnumVal));
			break;
		case COLUMN_DOT11WEPDEFAULTKEYID:
		//	rst=restore(&p_elem->WEPDefaultKeyID,sizeof(MYINTEGER));
			break;
		case COLUMN_DOT11WEPKEYMAPPINGLENGTH:
		//	rst=restore(&p_elem->WEPKeyMappingLength,sizeof(MYINTEGER));
			break;
		case COLUMN_DOT11EXCLUDEUNENCRYPTED:
		//	rst=restore(&p_elem->excludeUnencrypted,sizeof(MYEnumVal));
			break;
		default:
			break;
		}
		if(rst)
			netsnmp_set_request_error(reqinfo, request,SNMP_ERR_GENERR);
		break;
        default:
            snmp_log(LOG_ERR,
                     "problem encountered in dot11PrivacyTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}

typedef struct dot11OperationTable_elem_s{
	MYIfIndex		ifIndex;
	struct dot11OperationTable_elem_s *next;
	char			macAddress[6];
	//MYINTEGER	RTSThreshold;
	//MYINTEGER	shortRetryLimit;
	//MYINTEGER	longRetryLimit;
	//MYINTEGER	fragmentationThreshold;
	//MYINTEGER	maxTransmitMSDULifetime;
	//MYINTEGER	maxReceiveLifetime;
	char			manufacturerID[1+sizeof("Symbol")];
	char			productID[1+sizeof("CB3000")];
}dot11OperationTable_elem;

static dot11OperationTable_elem *dot11OperationTable;



/** Initialize the dot11OperationTable table by defining its contents and how it's structured */
void
initialize_table_dot11OperationTable(void)
{
	int i;
	
	IfList_elem* ifList;
	dot11OperationTable_elem *p_elem, *tail;

	for(ifList=g_ifList, i=0,dot11OperationTable=NULL; ifList; ifList=ifList->next, ++i)
	{
		p_elem=(dot11OperationTable_elem*)malloc(sizeof(dot11OperationTable_elem));
		if(p_elem)
		{
			p_elem->ifIndex=ifList->index;
			p_elem->next=NULL;
			memcpy(p_elem->macAddress,g_mac,6);
			//p_elem->RTSThreshold=intVal;
			//p_elem->shortRetryLimit=intVal;
			//p_elem->longRetryLimit=intVal;
			//p_elem->fragmentationThreshold=intVal;
			//p_elem->maxTransmitMSDULifetime=intVal;
			//p_elem->maxReceiveLifetime=intVal;
			strcpy(p_elem->manufacturerID,"Symbol");
			strcpy(p_elem->productID,"CB3000");
			if(dot11OperationTable==NULL)
				dot11OperationTable=p_elem;
			else
				tail->next=p_elem;
			tail=p_elem;
		}
		else
			break;
	}
    static oid      dot11OperationTable_oid[] = { 1, 2, 840, 10036, 2, 1 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /*
     * create the table structure itself 
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
     */
    my_handler = netsnmp_create_handler_registration("dot11OperationTable",
                                                     dot11OperationTable_handler,
                                                     dot11OperationTable_oid,
                                                     OID_LENGTH
                                                     (dot11OperationTable_oid),
                                                     HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: ifIndex */
                                     0);

    table_info->min_column = 1;
    table_info->max_column = 9;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point = dot11OperationTable_get_first_data_point;
    iinfo->get_next_data_point = dot11OperationTable_get_next_data_point;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_dot11OperationTable",
                "Registering table dot11OperationTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}

netsnmp_variable_list *
dot11OperationTable_get_first_data_point(void **my_loop_context,
                                         void **my_data_context,
                                         netsnmp_variable_list *
                                         put_index_data,
                                         netsnmp_iterator_info *mydata)
{
	dot11OperationTable_elem *p_elem;
	p_elem=dot11OperationTable;
	if(!p_elem)
		return NULL;
    
	*my_loop_context = p_elem ;
	*my_data_context = p_elem ;

	netsnmp_variable_list *vptr;
	vptr = put_index_data;

	snmp_set_var_value(vptr, (u_char *) &p_elem->ifIndex,sizeof(MYIfIndex));
	return put_index_data;
}


netsnmp_variable_list *
dot11OperationTable_get_next_data_point(void **my_loop_context,
                                        void **my_data_context,
                                        netsnmp_variable_list *
                                        put_index_data,
                                        netsnmp_iterator_info *mydata)
{
	dot11OperationTable_elem* p_elem;
	p_elem=(dot11OperationTable_elem*)*my_loop_context;
	p_elem=p_elem->next;
	if(!p_elem)
		return NULL;

	*my_loop_context = p_elem ;
	*my_data_context = p_elem ;
	
	netsnmp_variable_list *vptr;
	vptr = put_index_data;

	snmp_set_var_value(vptr, (u_char *) &p_elem->ifIndex,sizeof(MYIfIndex));

	return put_index_data;
}

/** handles requests for the dot11OperationTable table, if anything else needs to be done */
int
dot11OperationTable_handler(netsnmp_mib_handler *handler,
                            netsnmp_handler_registration *reginfo,
                            netsnmp_agent_request_info *reqinfo,
                            netsnmp_request_info *requests)
{
	dot11OperationTable_elem *p_elem;
	MYINTEGER	range_min,range_max;
    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
	FILE* fp;
	char command[100];
	MYINTEGER	value;
	int rst;

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed. 
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the dot11OperationTable table in question 
         */

	p_elem = (dot11OperationTable_elem *)netsnmp_extract_iterator_context(request);
        if (p_elem == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            
        }
	
        /*
         * extracts the information about the table from the request 
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested 
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request 
         */
        if (table_info == NULL) {
            continue;
        }

        switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here 
             */
             
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_DOT11MACADDRESS:
                snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                         (u_char *) p_elem->macAddress
                                         , 6 );
                break;

            case COLUMN_DOT11RTSTHRESHOLD:
		system("/usr/bin/get_rts >/tmp/data");
		fp=fopen("/tmp/data","r");
		if(fp)
		{
			if(fscanf(fp,"%d",&value)<0)
				value=0;
			fclose(fp);
		}
		else
			printf("can not open /tmp/data\n");
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &value,sizeof(MYINTEGER));
	
                break;

            case COLUMN_DOT11SHORTRETRYLIMIT:
		fp=fopen("/proc/sys/dev/ath0/shortretrylimit","r");
		if(fp)
		{
			fscanf(fp,"%d",&value);
			fclose(fp);
		}
		else
			printf("snmp need /proc/sys/dev/ath0/shortretrylimit\n");
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &value
                                         , sizeof(MYINTEGER));
                break;

            case COLUMN_DOT11LONGRETRYLIMIT:
		fp=fopen("/proc/sys/dev/ath0/longretrylimit","r");
		if(fp)
		{
			fscanf(fp,"%d",&value);
			fclose(fp);
		}
		else
			printf("snmp need /proc/sys/dev/ath0/longretrylimit\n");
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &value
                                         , sizeof(MYINTEGER) );
                break;

            case COLUMN_DOT11FRAGMENTATIONTHRESHOLD:
		fp=fopen("/proc/sys/dev/ath0/fragthreshold","r");
		if(fp)
		{
			fscanf(fp,"%d",&value);
			fclose(fp);
		}
		else
			printf("snmp need /proc/sys/dev/ath0/fragthreshold\n");
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &value
                                         , sizeof(MYINTEGER) );
                break;

            case COLUMN_DOT11MAXTRANSMITMSDULIFETIME:
		fp=fopen("/proc/sys/dev/ath0/txmsdulifetime","r");
		if(fp)
		{
			fscanf(fp,"%d",&value);
			fclose(fp);
		}
		else
			printf("snmp need /proc/sys/dev/ath0/txmsdulifetime\n");
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &value
                                         , sizeof(MYINTEGER) );
                break;

            case COLUMN_DOT11MAXRECEIVELIFETIME:
		fp=fopen("/proc/sys/dev/ath0/rxlifetime","r");
		if(fp)
		{
			fscanf(fp,"%d",&value);
			fclose(fp);
		}
		else
			printf("snmp need /proc/sys/dev/ath0/rxlifetime");
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &value
                                         , sizeof(MYINTEGER) );
                break;

            case COLUMN_DOT11MANUFACTURERID:
                snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                         (u_char *) p_elem->manufacturerID
                                         , strlen(p_elem->manufacturerID) );
                break;

            case COLUMN_DOT11PRODUCTID:
                snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                         (u_char *) p_elem->productID
                                         , strlen(p_elem->productID) );
                break;

            default:
                /*
                 * We shouldn't get here 
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in dot11OperationTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11RTSTHRESHOLD:
			range_min=0;
			range_max=2347;
			break;
		case COLUMN_DOT11SHORTRETRYLIMIT:
			range_min=1;
			range_max=255;
			break;
		case COLUMN_DOT11LONGRETRYLIMIT:
			range_min=1;
			range_max=255;
			break;
		case COLUMN_DOT11FRAGMENTATIONTHRESHOLD:
			range_min=256;
			range_max=2346;
			break;
		case COLUMN_DOT11MAXTRANSMITMSDULIFETIME:
			range_min=1;
			range_max=2147483647;
			break;
		case COLUMN_DOT11MAXRECEIVELIFETIME:
			range_min=1;
			range_max=2147483647;
			break;
		default:
			netsnmp_set_request_error(reqinfo, request,SNMP_ERR_READONLY);
			return SNMP_ERR_NOERROR;
		}
		if(var->type!=ASN_INTEGER)
			netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGTYPE);
		else if(var->val_len!=sizeof(MYINTEGER))
			netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGLENGTH);
		else if(*var->val.integer<range_min || *var->val.integer>range_max)
			netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGVALUE);
		else
			;
        	break;
	case MODE_SET_RESERVE2:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11RTSTHRESHOLD:
			//rst=backup(&p_elem->RTSThreshold,sizeof(MYINTEGER));
			break;
		case COLUMN_DOT11SHORTRETRYLIMIT:
			//rst=backup(&p_elem->shortRetryLimit,sizeof(MYINTEGER));
			break;
		case COLUMN_DOT11LONGRETRYLIMIT:
			//rst=backup(&p_elem->longRetryLimit,sizeof(MYINTEGER));
			break;
		case COLUMN_DOT11FRAGMENTATIONTHRESHOLD:
			//rst=backup(&p_elem->fragmentationThreshold,sizeof(MYINTEGER));
			break;
		case COLUMN_DOT11MAXTRANSMITMSDULIFETIME:
			//rst=backup(&p_elem->maxTransmitMSDULifetime,sizeof(MYINTEGER));
			break;
		case COLUMN_DOT11MAXRECEIVELIFETIME:
			//rst=backup(&p_elem->maxReceiveLifetime,sizeof(MYINTEGER));
			break;
		default:
			break;
		}
		/*
		if(rst)
			netsnmp_set_request_error(reqinfo, request,SNMP_ERR_GENERR);
		*/
		break;
	case MODE_SET_FREE:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11RTSTHRESHOLD:
		case COLUMN_DOT11SHORTRETRYLIMIT:
		case COLUMN_DOT11LONGRETRYLIMIT:
		case COLUMN_DOT11FRAGMENTATIONTHRESHOLD:
		case COLUMN_DOT11MAXTRANSMITMSDULIFETIME:
		case COLUMN_DOT11MAXRECEIVELIFETIME:
			//clear();
			break;
		default:
			break;
		}
		break;
	case MODE_SET_ACTION:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11RTSTHRESHOLD:
			sprintf(command,"/usr/bin/cfgset --rts %d",*var->val.integer);
			system(command);
			break;
		case COLUMN_DOT11SHORTRETRYLIMIT:
			sprintf(command,"echo \"%d\" >/proc/sys/dev/ath0/shortretrylimit",*var->val.integer);
			system(command);
			break;
		case COLUMN_DOT11LONGRETRYLIMIT:
			sprintf(command,"echo \"%d\" >/proc/sys/dev/ath0/longretrylimit",*var->val.integer);
			system(command);
			break;
		case COLUMN_DOT11FRAGMENTATIONTHRESHOLD:
			sprintf(command,"echo \"%d\" >/proc/sys/dev/ath0/fragthreshold",*var->val.integer);
			system(command);
			break;
		case COLUMN_DOT11MAXTRANSMITMSDULIFETIME:
			sprintf(command,"echo \"%d\" >/proc/sys/dev/ath0/txmsdulifetime",*var->val.integer);
			system(command);
			break;
		case COLUMN_DOT11MAXRECEIVELIFETIME:
			sprintf(command,"echo \"%d\" >/proc/sys/dev/ath0/rxlifetime",*var->val.integer);
			system(command);
			break;
		default:
			break;
		}
		break;
	case MODE_SET_COMMIT:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11RTSTHRESHOLD:
		case COLUMN_DOT11SHORTRETRYLIMIT:
		case COLUMN_DOT11LONGRETRYLIMIT:
		case COLUMN_DOT11FRAGMENTATIONTHRESHOLD:
		case COLUMN_DOT11MAXTRANSMITMSDULIFETIME:
		case COLUMN_DOT11MAXRECEIVELIFETIME:
			break;
		default:
			break;
		}
		break;
	case MODE_SET_UNDO:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11RTSTHRESHOLD:
			break;
		case COLUMN_DOT11SHORTRETRYLIMIT:
			break;
		case COLUMN_DOT11LONGRETRYLIMIT:
			break;
		case COLUMN_DOT11FRAGMENTATIONTHRESHOLD:
			break;
		case COLUMN_DOT11MAXTRANSMITMSDULIFETIME:
			break;
		case COLUMN_DOT11MAXRECEIVELIFETIME:
			break;
		default:
			break;
		}
		break;
        default:
            snmp_log(LOG_ERR,
                     "problem encountered in dot11OperationTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}

typedef struct dot11CountersTable_elem_s{
	MYIfIndex		ifIndex;
	struct dot11CountersTable_elem_s* next;
	//MYCounter	transmittedFragmentCount;
	//MYCounter	multicastTransmittedFrameCount;
	//MYCounter	failedCount;
	//MYCounter	retryCount;
	//MYCounter	multipleRetryCount;
	//MYCounter	frameDuplicateCount;
	//MYCounter	RTSSuccessCount;
	//MYCounter	RTSFailureCount;
	//MYCounter	ACKFailureCount;
	//MYCounter	receivedFragmentCount;
	//MYCounter	multicastReceivedFrameCount;
	//MYCounter	FCSErrorCount;
	//MYCounter	transmittedFrameCount;
	//MYCounter	WEPUndecryptableCount;
}dot11CountersTable_elem;
static dot11CountersTable_elem	*dot11CountersTable;

void
initialize_table_dot11CountersTable(void)
{
	int i;
	int intVal;
	IfList_elem* ifList;
	dot11CountersTable_elem *p_elem, *tail;
	for(ifList=g_ifList, i=0,dot11CountersTable=NULL; ifList; ifList=ifList->next, ++i)
	{
		intVal=i+1;
		p_elem=(dot11CountersTable_elem*)malloc(sizeof(dot11CountersTable_elem));
		if(p_elem)
		{
			p_elem->ifIndex=ifList->index;
			p_elem->next=NULL;
			//p_elem->transmittedFragmentCount=intVal;
			//p_elem->multicastTransmittedFrameCount=intVal;
			//p_elem->failedCount=intVal;
			//p_elem->retryCount=intVal;
			//p_elem->multipleRetryCount=intVal;
			//p_elem->frameDuplicateCount=intVal;
			//p_elem->RTSSuccessCount=intVal;
			//p_elem->RTSFailureCount=intVal;
			//p_elem->ACKFailureCount=intVal;
			//p_elem->receivedFragmentCount=intVal;
			//p_elem->multicastReceivedFrameCount=intVal;
			//p_elem->FCSErrorCount=intVal;
			//p_elem->transmittedFrameCount=intVal;
			//p_elem->WEPUndecryptableCount=intVal;
			if(dot11CountersTable==NULL)
				dot11CountersTable=p_elem;
			else
				tail->next=p_elem;
			tail=p_elem;
		}
		else
			break;
	}
    static oid      dot11CountersTable_oid[] = { 1, 2, 840, 10036, 2, 2 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /*
     * create the table structure itself 
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
     */
    my_handler = netsnmp_create_handler_registration("dot11CountersTable",
                                                     dot11CountersTable_handler,
                                                     dot11CountersTable_oid,
                                                     OID_LENGTH
                                                     (dot11CountersTable_oid),
                                                     HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: ifIndex */
                                     0);

    table_info->min_column = 1;
    table_info->max_column = 14;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point = dot11CountersTable_get_first_data_point;
    iinfo->get_next_data_point = dot11CountersTable_get_next_data_point;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_dot11CountersTable",
                "Registering table dot11CountersTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}


netsnmp_variable_list *
dot11CountersTable_get_first_data_point(void **my_loop_context,
                                        void **my_data_context,
                                        netsnmp_variable_list *
                                        put_index_data,
                                        netsnmp_iterator_info *mydata)
{
	dot11CountersTable_elem *p_elem;
	p_elem=dot11CountersTable;
	if(!p_elem)
		return NULL;	

	*my_loop_context = p_elem ;
	*my_data_context = p_elem ;

	netsnmp_variable_list *vptr;
	vptr = put_index_data;

	snmp_set_var_value(vptr, (u_char *) &p_elem->ifIndex,sizeof(MYIfIndex));
                      
	return put_index_data;
}



netsnmp_variable_list *
dot11CountersTable_get_next_data_point(void **my_loop_context,
                                       void **my_data_context,
                                       netsnmp_variable_list *
                                       put_index_data,
                                       netsnmp_iterator_info *mydata)
{
	dot11CountersTable_elem* p_elem;
	p_elem=(dot11CountersTable_elem*)*my_loop_context;
	p_elem=p_elem->next;
	if(!p_elem)
		return NULL;

	*my_loop_context = p_elem ;
	*my_data_context = p_elem ;

	netsnmp_variable_list *vptr;
	vptr = put_index_data;

	snmp_set_var_value(vptr, (u_char *) &p_elem->ifIndex,sizeof(MYIfIndex));
                      
	return put_index_data;
}

/** handles requests for the dot11CountersTable table, if anything else needs to be done */
int
dot11CountersTable_handler(netsnmp_mib_handler *handler,
                           netsnmp_handler_registration *reginfo,
                           netsnmp_agent_request_info *reqinfo,
                           netsnmp_request_info *requests)
{
	dot11CountersTable_elem* p_elem;
    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
	
	FILE* fp;
	MYCounter value;


    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed. 
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the dot11CountersTable table in question 
         */

         p_elem = (dot11CountersTable_elem *)netsnmp_extract_iterator_context(request);
        if ( p_elem == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            
        }

        /*
         * extracts the information about the table from the request 
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested 
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request 
         */
        if (table_info == NULL) {
            continue;
        }
        switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here 
             */
        case MODE_GET:
		value=88;
            switch (table_info->colnum) {
            case COLUMN_DOT11TRANSMITTEDFRAGMENTCOUNT:
                fp=fopen("/proc/sys/dev/ath0/txfragmentcount","r");
		if(fp)
		{
			fscanf(fp,"%d",&value);
			fclose(fp);
		}
		else
			printf("snmp need /proc/sys/dev/ath0/txfragmentcount\n");
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *) &value
                                         , sizeof(MYCounter));
                break;

            case COLUMN_DOT11MULTICASTTRANSMITTEDFRAMECOUNT:
		fp=fopen("/proc/sys/dev/ath0/multxframecount","r");
		if(fp)
		{
			fscanf(fp,"%d",&value);
			fclose(fp);
		}
		else
			printf("snmp need /proc/sys/dev/ath0/multxframecount\n");
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *) &value
                                         , sizeof(MYCounter));
                break;

            case COLUMN_DOT11FAILEDCOUNT:
		fp=fopen("/proc/sys/dev/ath0/failedcount","r");
		if(fp)
		{
			fscanf(fp,"%d",&value);
			fclose(fp);
		}
		else
			printf("snmp need /proc/sys/dev/ath0/failedcount\n");
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *)&value
                                         , sizeof(MYCounter) );
                break;

            case COLUMN_DOT11RETRYCOUNT:
                fp=fopen("/proc/sys/dev/ath0/retrycount","r");
		if(fp)
		{
			fscanf(fp,"%d",&value);
			fclose(fp);
		}
		else
			printf("snmp need /proc/sys/dev/ath0/retrycount\n");
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *)&value
                                         , sizeof(MYCounter) );
                break;

            case COLUMN_DOT11MULTIPLERETRYCOUNT:
                fp=fopen("/proc/sys/dev/ath0/mulretrycount","r");
		if(fp)
		{
			fscanf(fp,"%d",&value);
			fclose(fp);
		}
		else
			printf("snmp need /proc/sys/dev/ath0/mulretrycount\n");
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *)&value
                                         , sizeof(MYCounter) );
                break;

            case COLUMN_DOT11FRAMEDUPLICATECOUNT:
		fp=fopen("/proc/sys/dev/ath0/framedupcount","r");
		if(fp)
		{
			fscanf(fp,"%d",&value);
			fclose(fp);
		}
		else
			printf("snmp need /proc/sys/dev/ath0/framedupcount\n");
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *)&value
                                         , sizeof(MYCounter));
                break;

            case COLUMN_DOT11RTSSUCCESSCOUNT:
                fp=fopen("/proc/sys/dev/ath0/rtssuccesscount","r");
		if(fp)
		{
			fscanf(fp,"%d",&value);
			fclose(fp);
		}
		else
			printf("snmp need /proc/sys/dev/ath0/rtssuccesscount\n");
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *)&value
                                         , sizeof(MYCounter) );
                break;

            case COLUMN_DOT11RTSFAILURECOUNT:
                fp=fopen("/proc/sys/dev/ath0/rtsfailurecount","r");
		if(fp)
		{
			fscanf(fp,"%d",&value);
			fclose(fp);
		}
		else
			printf("snmp need /proc/sys/dev/ath0/rtsfailurecount\n");
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *)&value
                                         , sizeof(MYCounter) );
                break;

            case COLUMN_DOT11ACKFAILURECOUNT:
                fp=fopen("/proc/sys/dev/ath0/ackfailurecount","r");
		if(fp)
		{
			fscanf(fp,"%d",&value);
			fclose(fp);
		}
		else
			printf("snmp need /proc/sys/dev/ath0/ackfailurecount\n");
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *)&value
                                         , sizeof(MYCounter) );
                break;

            case COLUMN_DOT11RECEIVEDFRAGMENTCOUNT:
                fp=fopen("/proc/sys/dev/ath0/rxfragmentcount","r");
		if(fp)
		{
			fscanf(fp,"%d",&value);
			fclose(fp);
		}
		else
			printf("snmp need /proc/sys/dev/ath0/rxfragmentcount\n");
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *)&value
                                         , sizeof(MYCounter) );
                break;

            case COLUMN_DOT11MULTICASTRECEIVEDFRAMECOUNT:
                fp=fopen("/proc/sys/dev/ath0/mulcastrxframe","r");
		if(fp)
		{
			fscanf(fp,"%d",&value);
			fclose(fp);
		}
		else
			printf("snmp need /proc/sys/dev/ath0/mulcastrxframe\n");
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *)&value
                                         , sizeof(MYCounter) );
                break;

            case COLUMN_DOT11FCSERRORCOUNT:
		fp=fopen("/proc/sys/dev/ath0/fcserrorcount","r");
		if(fp)
		{
			fscanf(fp,"%d",&value);
			fclose(fp);
		}	
		else
			printf("snmp need /proc/sys/dev/ath0/fcserrorcount\n");
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *) &value
                                         , sizeof(MYCounter) );
                break;

            case COLUMN_DOT11TRANSMITTEDFRAMECOUNT:
                fp=fopen("/proc/sys/dev/ath0/txframecount","r");
		if(fp)
		{
			fscanf(fp,"%d",&value);
			fclose(fp);
		}
		else
			printf("snmp need /proc/sys/dev/ath0/txframecount\n");
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *)&value
                                         , sizeof(MYCounter) );
                break;

            case COLUMN_DOT11WEPUNDECRYPTABLECOUNT:
                fp=fopen("/proc/sys/dev/ath0/wepundecrypt","r");
		if(fp)
		{
			fscanf(fp,"%d",&value);
			fclose(fp);
		}
		else
			printf("snmp need /proc/sys/dev/ath0/wepundecrypt\n");
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *)&value
                                         , sizeof(MYCounter) );
                break;

            default:
                /*
                 * We shouldn't get here 
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in dot11CountersTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
         	netsnmp_set_request_error(reqinfo, request,SNMP_ERR_READONLY);
        	break;
	case MODE_SET_FREE:
		break;
        default:
            snmp_log(LOG_ERR,
                     "problem encountered in dot11CountersTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}

#if 0

typedef struct dot11GroupAddressesTable_elem_s{
	MYIfIndex		ifIndex;
	MYInteger32	groupAddressesIndex;
	struct dot11GroupAddressesTable_elem_s *next;
	char 			addr[6];
	MYEnumVal	groupAddressesStatus;
}dot11GroupAddressesTable_elem;

static dot11GroupAddressesTable_elem *dot11GroupAddressesTable;

void
initialize_table_dot11GroupAddressesTable(void)
{
	int i,j;
	char strVal[2];
	int intVal;
	IfList_elem* ifList;
	dot11GroupAddressesTable_elem *p_elem, *tail;
	for(ifList=g_ifList, i=0,dot11GroupAddressesTable=NULL; ifList; ifList=ifList->next, ++i)
	{
		for(j=0;j<DOT11GROUPADDRESSESTABLE_INDEX_MAX;++j)
		{
			strVal[0]=i+1;strVal[1]=j+1;
			intVal=(i+1)*10+j+1;
			p_elem=(dot11GroupAddressesTable_elem*)malloc(sizeof(dot11GroupAddressesTable_elem));
			if(p_elem)
			{
				p_elem->ifIndex=ifList->index;
				p_elem->groupAddressesIndex=j+1;
				p_elem->next=NULL;
				memcpy(p_elem->addr,strVal,2);
				p_elem->groupAddressesStatus=intVal;
				if(dot11GroupAddressesTable==NULL)
					dot11GroupAddressesTable=p_elem;
				else
					tail->next=p_elem;
				tail=p_elem;
			}
			else
			{
				ifList=NULL;
				break;
			}
		}
	}
    static oid      dot11GroupAddressesTable_oid[] =
        { 1, 2, 840, 10036, 2, 3 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /*
     * create the table structure itself 
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
     */
    my_handler =
        netsnmp_create_handler_registration("dot11GroupAddressesTable",
                                            dot11GroupAddressesTable_handler,
                                            dot11GroupAddressesTable_oid,
                                            OID_LENGTH
                                            (dot11GroupAddressesTable_oid),
                                            HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: ifIndex */
                                     ASN_INTEGER,       /* index: dot11GroupAddressesIndex */
                                     0);

    table_info->min_column = 2;
    table_info->max_column = 3;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point =
        dot11GroupAddressesTable_get_first_data_point;
    iinfo->get_next_data_point =
        dot11GroupAddressesTable_get_next_data_point;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_dot11GroupAddressesTable",
                "Registering table dot11GroupAddressesTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}



netsnmp_variable_list *
dot11GroupAddressesTable_get_first_data_point(void **my_loop_context,
                                              void **my_data_context,
                                              netsnmp_variable_list *
                                              put_index_data,
                                              netsnmp_iterator_info
                                              *mydata)
{
	dot11GroupAddressesTable_elem *p_elem;
	p_elem=dot11GroupAddressesTable;
	if(!p_elem)
		return NULL;

	*my_loop_context = p_elem ;
	*my_data_context = p_elem ;
	
	netsnmp_variable_list *vptr;
	vptr = put_index_data;

	snmp_set_var_value(vptr, (u_char *) &p_elem->ifIndex,sizeof(MYIfIndex));
	vptr = vptr->next_variable;
	snmp_set_var_value(vptr,(u_char *) &p_elem->groupAddressesIndex,sizeof(MYInteger32));
  
	return put_index_data;
}



netsnmp_variable_list *
dot11GroupAddressesTable_get_next_data_point(void **my_loop_context,
                                             void **my_data_context,
                                             netsnmp_variable_list *
                                             put_index_data,
                                             netsnmp_iterator_info *mydata)
{
	dot11GroupAddressesTable_elem *p_elem;
	p_elem=(dot11GroupAddressesTable_elem*)*my_loop_context;
	p_elem=p_elem->next;
	if(!p_elem)
		return NULL;

	*my_loop_context = p_elem;
	*my_data_context = p_elem ; 

	netsnmp_variable_list *vptr;
	vptr = put_index_data;

	snmp_set_var_value(vptr, (u_char *) &p_elem->ifIndex,sizeof(MYIfIndex));
	vptr = vptr->next_variable;
	snmp_set_var_value(vptr,(u_char *) &p_elem->groupAddressesIndex,sizeof(MYInteger32));
  
	return put_index_data;
}

/** handles requests for the dot11GroupAddressesTable table, if anything else needs to be done */
int
dot11GroupAddressesTable_handler(netsnmp_mib_handler *handler,
                                 netsnmp_handler_registration *reginfo,
                                 netsnmp_agent_request_info *reqinfo,
                                 netsnmp_request_info *requests)
{
	dot11GroupAddressesTable_elem *p_elem;
    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed. 
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the dot11GroupAddressesTable table in question 
         */

	p_elem = (dot11GroupAddressesTable_elem *)netsnmp_extract_iterator_context(request);
        if (p_elem == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            
        }

        /*
         * extracts the information about the table from the request 
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested 
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request 
         */
        if (table_info == NULL) {
            continue;
        }

        switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here 
             */
             
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_DOT11ADDRESS:
                snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                         (u_char *) p_elem->addr, 6 );
                break;

            case COLUMN_DOT11GROUPADDRESSESSTATUS:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &p_elem->groupAddressesStatus
                                         , sizeof(MYEnumVal) );
                break;

            default:
                /*
                 * We shouldn't get here 
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in dot11GroupAddressesTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
		netsnmp_set_request_error(reqinfo, request,SNMP_ERR_READONLY);
		break;
	case MODE_SET_FREE:
		break;
        default:
            snmp_log(LOG_ERR,
                     "problem encountered in dot11GroupAddressesTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}

#endif

typedef struct dot11ResourceInfoTable_elem_s{
	MYIfIndex		ifIndex;
	struct dot11ResourceInfoTable_elem_s *next;
	char	manufacturerOUI[3];
	char manufacturerName[1+sizeof("Symbol")];
	char manufacturerProductName[1+sizeof("CB3000")];
	char manufacturerProductVersion[1+sizeof("manufacturerProductVersion")];
}dot11ResourceInfoTable_elem;

static dot11ResourceInfoTable_elem *dot11ResourceInfoTable;
	
void
initialize_table_dot11ResourceInfoTable(void)
{
	char version[50];
	FILE *fp;
	fp=fopen("/firmware.version","r");
	if(fp)
	{
		fscanf(fp,"%s",version);
		fclose(fp);
	}
	else
		strcpy(version,"unknow");
	
	int i;
	char strVal[1];
	IfList_elem* ifList;
	dot11ResourceInfoTable_elem *p_elem, *tail;
	for(ifList=g_ifList, i=0,dot11ResourceInfoTable=NULL; ifList; ifList=ifList->next, ++i)
	{
		strVal[0]=i+1;
		p_elem=(dot11ResourceInfoTable_elem*)malloc(sizeof(dot11ResourceInfoTable_elem));
		if(p_elem)
		{
			p_elem->ifIndex=ifList->index;
			p_elem->next=NULL;
			p_elem->manufacturerOUI[0]=0x00;
			p_elem->manufacturerOUI[1]=0x03;
			p_elem->manufacturerOUI[2]=0x7f;
			strcpy(p_elem->manufacturerName,"Symbol");
			strcpy(p_elem->manufacturerProductName,"CB3000");
			strcpy(p_elem->manufacturerProductVersion,version);
			if(dot11ResourceInfoTable==NULL)
				dot11ResourceInfoTable=p_elem;
			else
				tail->next=p_elem;
			tail=p_elem;
		}
		else
			break;
	}
    static oid      dot11ResourceInfoTable_oid[] =
        { 1, 2, 840, 10036, 3, 1, 2 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /*
     * create the table structure itself 
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
     */
    my_handler =
        netsnmp_create_handler_registration("dot11ResourceInfoTable",
                                            dot11ResourceInfoTable_handler,
                                            dot11ResourceInfoTable_oid,
                                            OID_LENGTH
                                            (dot11ResourceInfoTable_oid),
                                            HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: ifIndex */
                                     0);

    table_info->min_column = 1;
    table_info->max_column = 4;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point =
        dot11ResourceInfoTable_get_first_data_point;
    iinfo->get_next_data_point =
        dot11ResourceInfoTable_get_next_data_point;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_dot11ResourceInfoTable",
                "Registering table dot11ResourceInfoTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}

netsnmp_variable_list *
dot11ResourceInfoTable_get_first_data_point(void **my_loop_context,
                                            void **my_data_context,
                                            netsnmp_variable_list *
                                            put_index_data,
                                            netsnmp_iterator_info *mydata)
{
	dot11ResourceInfoTable_elem* p_elem;
	p_elem=dot11ResourceInfoTable;
	if(!p_elem)
		return NULL;

	*my_loop_context = p_elem ;
	*my_data_context = p_elem ;

	netsnmp_variable_list *vptr;
	vptr = put_index_data;

	snmp_set_var_value(vptr, (u_char *) &p_elem->ifIndex,sizeof(MYIfIndex));
     
	return put_index_data;
}


netsnmp_variable_list *
dot11ResourceInfoTable_get_next_data_point(void **my_loop_context,
                                           void **my_data_context,
                                           netsnmp_variable_list *
                                           put_index_data,
                                           netsnmp_iterator_info *mydata)
{
	dot11ResourceInfoTable_elem *p_elem;
	p_elem=(dot11ResourceInfoTable_elem*)*my_loop_context;
	p_elem=p_elem->next;
	if(!p_elem)
		return NULL;

	*my_loop_context = p_elem;
	*my_data_context = p_elem ;

	netsnmp_variable_list *vptr;
	vptr = put_index_data;

	snmp_set_var_value(vptr, (u_char *) &p_elem->ifIndex,sizeof(MYIfIndex));
     
	return put_index_data;
}

/** handles requests for the dot11ResourceInfoTable table, if anything else needs to be done */
int
dot11ResourceInfoTable_handler(netsnmp_mib_handler *handler,
                               netsnmp_handler_registration *reginfo,
                               netsnmp_agent_request_info *reqinfo,
                               netsnmp_request_info *requests)
{
	dot11ResourceInfoTable_elem *p_elem;
    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed. 
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the dot11ResourceInfoTable table in question 
         */

        p_elem = (dot11ResourceInfoTable_elem*)netsnmp_extract_iterator_context(request);
        if (p_elem == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
          
        }
	
        /*
         * extracts the information about the table from the request 
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested 
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request 
         */
        if (table_info == NULL) {
            continue;
        }

        switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here 
             */

        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_DOT11MANUFACTUREROUI:
                snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                         (u_char *) p_elem->manufacturerOUI, 3 );
                break;

            case COLUMN_DOT11MANUFACTURERNAME:
                snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                         (u_char *) p_elem->manufacturerName
                                         , strlen(p_elem->manufacturerName) );
                break;

            case COLUMN_DOT11MANUFACTURERPRODUCTNAME:
                snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                         (u_char *) p_elem->manufacturerProductName
                                         , strlen(p_elem->manufacturerProductName) );
                break;

            case COLUMN_DOT11MANUFACTURERPRODUCTVERSION:
                snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                         (u_char *) p_elem->manufacturerProductVersion
                                         , strlen(p_elem->manufacturerProductVersion));
                break;

            default:
                /*
                 * We shouldn't get here 
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in dot11ResourceInfoTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
		netsnmp_set_request_error(reqinfo, request,SNMP_ERR_READONLY);
		break;
	case MODE_SET_FREE:
		break;
        default:
            snmp_log(LOG_ERR,
                     "problem encountered in dot11ResourceInfoTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}

typedef struct dot11PhyOperationTable_elem_s{
	MYIfIndex		ifIndex;
	struct dot11PhyOperationTable_elem_s *next;
	MYEnumVal	phyType;
	//MYInteger32	curRegDomain; dynamic
	MYEnumVal	tempType;
}dot11PhyOperationTable_elem;

static dot11PhyOperationTable_elem *dot11PhyOperationTable;
	
void
initialize_table_dot11PhyOperationTable(void)
{
	int i;
	IfList_elem* ifList;
	dot11PhyOperationTable_elem *p_elem, *tail;
	for(ifList=g_ifList, i=0,dot11PhyOperationTable=NULL; ifList; ifList=ifList->next, ++i)
	{
		p_elem=(dot11PhyOperationTable_elem*)malloc(sizeof(dot11PhyOperationTable_elem));
		if(p_elem)
		{
			p_elem->ifIndex=ifList->index;
			p_elem->next=NULL;
			p_elem->phyType=6;
			//p_elem->curRegDomain=intVal;
			p_elem->tempType=1;
			if(dot11PhyOperationTable==NULL)
				dot11PhyOperationTable=p_elem;
			else
				tail->next=p_elem;
			tail=p_elem;
		}
		else
			break;
	}
    static oid      dot11PhyOperationTable_oid[] =
        { 1, 2, 840, 10036, 4, 1 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /*
     * create the table structure itself 
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
     */
    my_handler =
        netsnmp_create_handler_registration("dot11PhyOperationTable",
                                            dot11PhyOperationTable_handler,
                                            dot11PhyOperationTable_oid,
                                            OID_LENGTH
                                            (dot11PhyOperationTable_oid),
                                            HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: ifIndex */
                                     0);

    table_info->min_column = 1;
    table_info->max_column = 3;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point =
        dot11PhyOperationTable_get_first_data_point;
    iinfo->get_next_data_point =
        dot11PhyOperationTable_get_next_data_point;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_dot11PhyOperationTable",
                "Registering table dot11PhyOperationTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}

netsnmp_variable_list *
dot11PhyOperationTable_get_first_data_point(void **my_loop_context,
                                            void **my_data_context,
                                            netsnmp_variable_list *
                                            put_index_data,
                                            netsnmp_iterator_info *mydata)
{
	dot11PhyOperationTable_elem *p_elem;
	p_elem=dot11PhyOperationTable;
	if(!p_elem)
		return NULL;

	*my_loop_context = p_elem ;
	*my_data_context = p_elem ;

	netsnmp_variable_list *vptr;
	vptr = put_index_data;

	snmp_set_var_value(vptr, (u_char *) &p_elem->ifIndex, sizeof(MYIfIndex));

	return put_index_data;
}

netsnmp_variable_list *
dot11PhyOperationTable_get_next_data_point(void **my_loop_context,
                                           void **my_data_context,
                                           netsnmp_variable_list *
                                           put_index_data,
                                           netsnmp_iterator_info *mydata)
{
	dot11PhyOperationTable_elem *p_elem;
	p_elem=(dot11PhyOperationTable_elem*)*my_loop_context;
	p_elem=p_elem->next;
	if(!p_elem)
		return NULL;
	*my_loop_context = p_elem ;
	*my_data_context = p_elem ; 

	netsnmp_variable_list *vptr;
	vptr = put_index_data;

	snmp_set_var_value(vptr, (u_char *) &p_elem->ifIndex, sizeof(MYIfIndex));

	return put_index_data;
}

/** handles requests for the dot11PhyOperationTable table, if anything else needs to be done */
int
dot11PhyOperationTable_handler(netsnmp_mib_handler *handler,
                               netsnmp_handler_registration *reginfo,
                               netsnmp_agent_request_info *reqinfo,
                               netsnmp_request_info *requests)
{
	dot11PhyOperationTable_elem *p_elem;
    	netsnmp_request_info *request;
    	netsnmp_table_request_info *table_info;
    	netsnmp_variable_list *var;
	FILE* fp;
	char command[50];
	int index;
	const MYInteger32 data[68]={
/*1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 */
  0, 0, 48,0, 0, 48,0, 48,32,0, 0, 0, 0, 48,48,48,0, 0, 48,48,48,48,48,0, 48,48,0, 0, 48,0, 48,64,0, 0, 0, 0, 48,48,
//39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68
  48,0, 0, 0, 48,0, 48,0, 48,0, 48,48,0, 48,48,0, 0, 48,0, 0, 48,0, 0, 48,48,48,16,0, 0, 0
};

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed. 
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the dot11PhyOperationTable table in question 
         */

        p_elem = (dot11PhyOperationTable_elem *)netsnmp_extract_iterator_context(request);
	if (p_elem == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            
        }

        /*
         * extracts the information about the table from the request 
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested 
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request 
         */
        if (table_info == NULL) {
            continue;
        }
        switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here 
             */
             
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_DOT11PHYTYPE:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &p_elem->phyType
                                         , sizeof(MYEnumVal) );
                break;

            case COLUMN_DOT11CURRENTREGDOMAIN:
		system("/usr/bin/get_country >/tmp/data");
		fp=fopen("/tmp/data","r");
		if(fp)
		{
			fscanf(fp,"%d",&index);
			fclose(fp);
		}
		if(index<1||index>68)
		{
			index=1;
			snmp_log(LOG_ERR,"/usr/bin/get_country return error value");
		}
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &data[index-1] , sizeof(MYInteger32) );
                break;

            case COLUMN_DOT11TEMPTYPE:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &p_elem->tempType
                                         , sizeof(MYEnumVal) );
                break;

            default:
                /*
                 * We shouldn't get here 
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in dot11PhyOperationTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11CURRENTREGDOMAIN:
			if(var->type!=ASN_INTEGER)
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGTYPE);
			else if(var->val_len!=sizeof(MYInteger32))
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGLENGTH);
			else if(*var->val.integer!=16 && *var->val.integer!=32 
			      &&*var->val.integer!=48 && *var->val.integer!=64)
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGVALUE);
			else
				;
			break;
		default:
			netsnmp_set_request_error(reqinfo, request,SNMP_ERR_READONLY);
			break;
		}
        	break;
	case MODE_SET_RESERVE2:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11CURRENTREGDOMAIN:
			/*
			if(backup(&p_elem->curRegDomain,sizeof(MYInteger32)))
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_GENERR);
			*/
			break;
		default:
			break;
		}
		break;
	case MODE_SET_FREE:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11CURRENTREGDOMAIN:
		//	clear();
			break;
		default:
			break;
		}
		break;
	case MODE_SET_ACTION:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11CURRENTREGDOMAIN:
			if(*var->val.integer!=48)
                        {
                                for(index=0;index<68;++index)
                                        if(*var->val.integer==data[index])
                                                break;
                                sprintf(command,"/usr/bin/cfgset --country %d",index+1);
                                system(command);
                        }
			break;
		default:
			break;
		}
		break;
	case MODE_SET_COMMIT:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11CURRENTREGDOMAIN:
			break;
		default:
			break;
		}
		break;
	case MODE_SET_UNDO:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11CURRENTREGDOMAIN:
			break;
		default:
			break;
		}
		break;
        default:
            snmp_log(LOG_ERR,
                     "problem encountered in dot11PhyOperationTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}

typedef struct dot11PhyAntennaTable_elem_s{
	MYIfIndex		ifIndex;
	struct dot11PhyAntennaTable_elem_s *next;
//	MYInteger32	curTxAntenna;	dynamic
	MYEnumVal	diversitySupport;
//	MYInteger32	curRxAntenna; dynamic
}dot11PhyAntennaTable_elem;

static dot11PhyAntennaTable_elem *dot11PhyAntennaTable;

void
initialize_table_dot11PhyAntennaTable(void)
{
	int i;
	IfList_elem* ifList;
	dot11PhyAntennaTable_elem *p_elem, *tail;
	for(ifList=g_ifList, i=0,dot11PhyAntennaTable=NULL; ifList; ifList=ifList->next, ++i)
	{
		p_elem=(dot11PhyAntennaTable_elem*)malloc(sizeof(dot11PhyAntennaTable_elem));
		if(p_elem)
		{
			p_elem->ifIndex=ifList->index;
			p_elem->next=NULL;
			//p_elem->curTxAntenna=intVal;
			p_elem->diversitySupport=3;
			//p_elem->curRxAntenna=intVal;
			if(dot11PhyAntennaTable==NULL)
				dot11PhyAntennaTable=p_elem;
			else
				tail->next=p_elem;
			tail=p_elem;
		}
		else
			break;
	}
    static oid      dot11PhyAntennaTable_oid[] =
        { 1, 2, 840, 10036, 4, 2 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /*
     * create the table structure itself 
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
     */
    my_handler =
        netsnmp_create_handler_registration("dot11PhyAntennaTable",
                                            dot11PhyAntennaTable_handler,
                                            dot11PhyAntennaTable_oid,
                                            OID_LENGTH
                                            (dot11PhyAntennaTable_oid),
                                            HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: ifIndex */
                                     0);

    table_info->min_column = 1;
    table_info->max_column = 3;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point =
        dot11PhyAntennaTable_get_first_data_point;
    iinfo->get_next_data_point = dot11PhyAntennaTable_get_next_data_point;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_dot11PhyAntennaTable",
                "Registering table dot11PhyAntennaTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}


netsnmp_variable_list *
dot11PhyAntennaTable_get_first_data_point(void **my_loop_context,
                                          void **my_data_context,
                                          netsnmp_variable_list *
                                          put_index_data,
                                          netsnmp_iterator_info *mydata)
{
	dot11PhyAntennaTable_elem *p_elem;
	p_elem=dot11PhyAntennaTable;
	if(!p_elem)
		return NULL;
	
	*my_loop_context = p_elem ;
	*my_data_context = p_elem ;
	
	netsnmp_variable_list *vptr;
	vptr = put_index_data;

	snmp_set_var_value(vptr, (u_char *) &p_elem->ifIndex,sizeof(MYIfIndex));
                      
	return put_index_data;
}


netsnmp_variable_list *
dot11PhyAntennaTable_get_next_data_point(void **my_loop_context,
                                         void **my_data_context,
                                         netsnmp_variable_list *
                                         put_index_data,
                                         netsnmp_iterator_info *mydata)
{
	dot11PhyAntennaTable_elem *p_elem;
	p_elem =(dot11PhyAntennaTable_elem*)*my_loop_context;
	p_elem=p_elem->next;
	if(!p_elem)
		return NULL;

	*my_loop_context = p_elem ;
	*my_data_context = p_elem ;

	netsnmp_variable_list *vptr;
	vptr = put_index_data;
	snmp_set_var_value(vptr, (u_char *) &p_elem->ifIndex,sizeof(MYIfIndex));
                     
    return put_index_data;
}

/** handles requests for the dot11PhyAntennaTable table, if anything else needs to be done */
int
dot11PhyAntennaTable_handler(netsnmp_mib_handler *handler,
                             netsnmp_handler_registration *reginfo,
                             netsnmp_agent_request_info *reqinfo,
                             netsnmp_request_info *requests)
{
	dot11PhyAntennaTable_elem *p_elem;
	int rst;
    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
	FILE* fp;
	char c;
	char command[50];
	MYInteger32	curTxAntenna;
	MYEnumVal	diversitySupport;
	MYInteger32	curRxAntenna;
    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed. 
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the dot11PhyAntennaTable table in question 
         */

        p_elem = (dot11PhyAntennaTable_elem*)netsnmp_extract_iterator_context(request);
	if (p_elem == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
           
        }
	
        /*
         * extracts the information about the table from the request 
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested 
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request 
         */
        if (table_info == NULL) {
            continue;
        }

        switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here 
             */
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_DOT11CURRENTTXANTENNA:
		fp=fopen("/proc/sys/dev/ath0/txantenna","r");
		if(fp)
		{
			fscanf(fp,"%d",&curTxAntenna);
			curTxAntenna+=1;
			fclose(fp);
		}
		else
			printf("snmp need /proc/sys/dev/ath0/txantenna\n");
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *)& curTxAntenna
                                         , sizeof(MYInteger32) );
                break;

            case COLUMN_DOT11DIVERSITYSUPPORT:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &p_elem->diversitySupport
                                         , sizeof(MYEnumVal) );
                break;

            case COLUMN_DOT11CURRENTRXANTENNA:
		fp=fopen("/proc/sys/dev/ath0/rxantenna","r");
		if(fp)
		{
			fscanf(fp,"%d",&curRxAntenna);
			curRxAntenna+=1;
			fclose(fp);
		}
		else
			printf("snmp need /proc/sys/dev/ath0/rxantenna\n");
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &curRxAntenna
                                         , sizeof(MYInteger32) );
                break;

            default:
                /*
                 * We shouldn't get here 
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in dot11PhyAntennaTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11CURRENTTXANTENNA:
		case COLUMN_DOT11CURRENTRXANTENNA:
			if(var->type!=ASN_INTEGER)
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGTYPE);
			else if(var->val_len!=sizeof(MYInteger32))
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGLENGTH);
			else if(*var->val.integer<1 ||*var->val.integer>2)
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGVALUE);
			else
				;
			break;
		default:
			netsnmp_set_request_error(reqinfo, request,SNMP_ERR_READONLY);
			break;
		}
        	break;
	case MODE_SET_RESERVE2:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11CURRENTTXANTENNA:
			//rst=backup(&p_elem->curTxAntenna,sizeof(MYInteger32));
		case COLUMN_DOT11CURRENTRXANTENNA:
			//rst=backup(&p_elem->curRxAntenna,sizeof(MYInteger32));
			break;
		default:
			break;
		}
		/*
		if(rst)
			netsnmp_set_request_error(reqinfo, request,SNMP_ERR_GENERR);
			*/
		break;
	case MODE_SET_FREE:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11CURRENTTXANTENNA:
		case COLUMN_DOT11CURRENTRXANTENNA:
			//clear();
			break;
		default:
			break;
		}
		break;
	case MODE_SET_ACTION:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11CURRENTTXANTENNA:
			sprintf(command,"echo \"%d\" > /proc/sys/dev/ath0/txantenna",*var->val.integer-1);
			system(command);
			break;
		case COLUMN_DOT11CURRENTRXANTENNA:
			sprintf(command,"echo \"%d\" > /proc/sys/dev/ath0/rxantenna",*var->val.integer-1);
			system(command);
			break;
		default:
			break;
		}
		break;
	case MODE_SET_COMMIT:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11CURRENTTXANTENNA:
		case COLUMN_DOT11CURRENTRXANTENNA:
		//	clear();
			break;
		default:
			break;
		}
		break;
	case MODE_SET_UNDO:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11CURRENTTXANTENNA:
			//rst=restore(&p_elem->curTxAntenna,sizeof(MYInteger32));
		case COLUMN_DOT11CURRENTRXANTENNA:
			//rst=restore(&p_elem->curRxAntenna,sizeof(MYInteger32));
			break;
		default:
			break;
		}
		/*
		if(rst)
			netsnmp_set_request_error(reqinfo, request,SNMP_ERR_GENERR);
			*/
		break;
        default:
            snmp_log(LOG_ERR,
                     "problem encountered in dot11PhyAntennaTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}

typedef struct dot11PhyTxPowerTable_elem_s{
	MYIfIndex		ifIndex;
	struct dot11PhyTxPowerTable_elem_s *next;
	MYINTEGER	numberSupportedPowerLevels;
	MYINTEGER	TxPowerLevel1;
	MYINTEGER	TxPowerLevel2;
	MYINTEGER	TxPowerLevel3;
	MYINTEGER	TxPowerLevel4;
	MYINTEGER	TxPowerLevel5;
	MYINTEGER	TxPowerLevel6;
	MYINTEGER	TxPowerLevel7;
	MYINTEGER	TxPowerLevel8;
//	MYINTEGER	currentTxPowerLevel;
	
}dot11PhyTxPowerTable_elem;

static dot11PhyTxPowerTable_elem *dot11PhyTxPowerTable;

void
initialize_table_dot11PhyTxPowerTable(void)
{
	int i;
	IfList_elem* ifList;
	dot11PhyTxPowerTable_elem *p_elem, *tail;
	for(ifList=g_ifList, i=0,dot11PhyTxPowerTable=NULL; ifList; ifList=ifList->next, ++i)
	{
		p_elem=(dot11PhyTxPowerTable_elem*)malloc(sizeof(dot11PhyTxPowerTable_elem));
		if(p_elem)
		{
			p_elem->ifIndex=ifList->index;
			p_elem->next=NULL;
			p_elem->numberSupportedPowerLevels=8;
			p_elem->TxPowerLevel1=6;
			p_elem->TxPowerLevel2=8;
			p_elem->TxPowerLevel3=10;
			p_elem->TxPowerLevel4=12;
			p_elem->TxPowerLevel5=14;
			p_elem->TxPowerLevel6=16;
			p_elem->TxPowerLevel7=18;
			p_elem->TxPowerLevel8=20;
			//p_elem->currentTxPowerLevel=1; dynamic
			if(dot11PhyTxPowerTable==NULL)
				dot11PhyTxPowerTable=p_elem;
			else
				tail->next=p_elem;
			tail=p_elem;
		}
		else
			break;
		
	}
    static oid      dot11PhyTxPowerTable_oid[] =
        { 1, 2, 840, 10036, 4, 3 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /*
     * create the table structure itself 
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
     */
    my_handler =
        netsnmp_create_handler_registration("dot11PhyTxPowerTable",
                                            dot11PhyTxPowerTable_handler,
                                            dot11PhyTxPowerTable_oid,
                                            OID_LENGTH
                                            (dot11PhyTxPowerTable_oid),
                                            HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: ifIndex */
                                     0);

    table_info->min_column = 1;
    table_info->max_column = 10;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point =
        dot11PhyTxPowerTable_get_first_data_point;
    iinfo->get_next_data_point = dot11PhyTxPowerTable_get_next_data_point;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_dot11PhyTxPowerTable",
                "Registering table dot11PhyTxPowerTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}


netsnmp_variable_list *
dot11PhyTxPowerTable_get_first_data_point(void **my_loop_context,
                                          void **my_data_context,
                                          netsnmp_variable_list *
                                          put_index_data,
                                          netsnmp_iterator_info *mydata)
{
	dot11PhyTxPowerTable_elem *p_elem;
	p_elem=dot11PhyTxPowerTable;
	if(!p_elem)
		return NULL;

	*my_loop_context = p_elem ;
	*my_data_context = p_elem ;

	netsnmp_variable_list *vptr;
	vptr = put_index_data;

	snmp_set_var_value(vptr, (u_char *) &p_elem->ifIndex,sizeof(MYIfIndex));
                      
	return put_index_data;
}



netsnmp_variable_list *
dot11PhyTxPowerTable_get_next_data_point(void **my_loop_context,
                                         void **my_data_context,
                                         netsnmp_variable_list *
                                         put_index_data,
                                         netsnmp_iterator_info *mydata)
{
	dot11PhyTxPowerTable_elem *p_elem;
	p_elem=(dot11PhyTxPowerTable_elem*)*my_loop_context;
	p_elem=p_elem->next;
	if(!p_elem)
		return NULL;
	*my_loop_context = p_elem ;
	*my_data_context = p_elem ;

	netsnmp_variable_list *vptr;
	vptr = put_index_data;

	snmp_set_var_value(vptr, (u_char *) &p_elem->ifIndex,sizeof(MYIfIndex));
                      
	return put_index_data;
}

/** handles requests for the dot11PhyTxPowerTable table, if anything else needs to be done */
int
dot11PhyTxPowerTable_handler(netsnmp_mib_handler *handler,
                             netsnmp_handler_registration *reginfo,
                             netsnmp_agent_request_info *reqinfo,
                             netsnmp_request_info *requests)
{
	dot11PhyTxPowerTable_elem *p_elem;
    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
	
	//variable for get currentTxPowerLevel
	FILE *fp;
	int power;
	MYINTEGER currentTxPowerLevel;
	char c;
	char command[50];
	
    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed. 
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the dot11PhyTxPowerTable table in question 
         */

        p_elem = (dot11PhyTxPowerTable_elem *)netsnmp_extract_iterator_context(request);
        if (p_elem == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
           
        }
        /*
         * extracts the information about the table from the request 
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested 
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request 
         */
        if (table_info == NULL) {
            continue;
        }

        switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here 
             */
           case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_DOT11NUMBERSUPPORTEDPOWERLEVELS:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &p_elem->numberSupportedPowerLevels
                                         , sizeof(MYINTEGER) );
                break;

            case COLUMN_DOT11TXPOWERLEVEL1:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &p_elem->TxPowerLevel1
                                         , sizeof(MYINTEGER) );
                break;

            case COLUMN_DOT11TXPOWERLEVEL2:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &p_elem->TxPowerLevel2
                                         , sizeof(MYINTEGER));
                break;

            case COLUMN_DOT11TXPOWERLEVEL3:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &p_elem->TxPowerLevel3
                                         , sizeof(MYINTEGER) );
                break;

            case COLUMN_DOT11TXPOWERLEVEL4:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &p_elem->TxPowerLevel4
                                         , sizeof(MYINTEGER) );
                break;

            case COLUMN_DOT11TXPOWERLEVEL5:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &p_elem->TxPowerLevel5
                                         , sizeof(MYINTEGER));
                break;

            case COLUMN_DOT11TXPOWERLEVEL6:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &p_elem->TxPowerLevel6
                                         ,sizeof(MYINTEGER) );
                break;

            case COLUMN_DOT11TXPOWERLEVEL7:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &p_elem->TxPowerLevel7
                                         , sizeof(MYINTEGER));
                break;

            case COLUMN_DOT11TXPOWERLEVEL8:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &p_elem->TxPowerLevel8
                                         , sizeof(MYINTEGER));
                break;

            case COLUMN_DOT11CURRENTTXPOWERLEVEL:
		system("/usr/bin/get_power_level>/tmp/data");
		fp=fopen("/tmp/data","r");
		currentTxPowerLevel=0;
		if(fp)
		{
			fscanf(fp,"%d",&power);
			fclose(fp);
			power=20-power;
			if(power<=6)
				currentTxPowerLevel=1;
			else
				currentTxPowerLevel=(power-3)/2;
		}
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &currentTxPowerLevel
                                         , sizeof(MYINTEGER));
                break;

            default:
                /*
                 * We shouldn't get here 
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in dot11PhyTxPowerTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11CURRENTTXPOWERLEVEL:
			if(var->type!=ASN_INTEGER)
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGTYPE);
			else if(var->val_len!=sizeof(MYINTEGER))
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGLENGTH);
			else if(*var->val.integer<1 || *var->val.integer>8)
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGVALUE);
			else
				;
			break;
		default:
			netsnmp_set_request_error(reqinfo, request,SNMP_ERR_READONLY);
			break;
		}
        	break;
	case MODE_SET_RESERVE2:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11CURRENTTXPOWERLEVEL:
			break;
		default:
			break;
		}
		break;
	case MODE_SET_FREE:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11CURRENTTXPOWERLEVEL:
			break;
		default:
			break;
		}
		break;
	case MODE_SET_ACTION:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11CURRENTTXPOWERLEVEL:
			power=20-(*var->val.integer*2+4);
			sprintf(command,"/usr/bin/cfgset --power_level %d",power);
			system(command);
			break;
		default:
			break;
		}
		break;
	case MODE_SET_COMMIT:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11CURRENTTXPOWERLEVEL:
			break;
		default:
			break;
		}
		break;
	case MODE_SET_UNDO:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11CURRENTTXPOWERLEVEL:
			break;
		default:
			break;
		}
		break;
        default:
            snmp_log(LOG_ERR,
                     "problem encountered in dot11PhyTxPowerTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}
#if 0
typedef struct dot11PhyFHSSTable_elem_s{
	MYIfIndex		ifIndex;
	struct dot11PhyFHSSTable_elem_s *next;
	MYINTEGER	hopTime;
	MYINTEGER	curChannellNum;
	MYINTEGER	maxDwellTime;
	MYINTEGER	curDwellTime;
	MYINTEGER	curSet;
	MYINTEGER	curPattern;
	MYINTEGER	curIndex;
}dot11PhyFHSSTable_elem;

dot11PhyFHSSTable_elem *dot11PhyFHSSTable;
void
initialize_table_dot11PhyFHSSTable(void)
{
	int i;
	int intVal;
	IfList_elem* ifList;
	dot11PhyFHSSTable_elem *p_elem, *tail;
	for(ifList=g_ifList, i=0,dot11PhyFHSSTable=NULL; ifList; ifList=ifList->next, ++i)
	{
		intVal=i+1;
		p_elem=(dot11PhyFHSSTable_elem*)malloc(sizeof(dot11PhyFHSSTable_elem));
		if(p_elem)
		{
			p_elem->ifIndex=ifList->index;
			p_elem->next=NULL;
			p_elem->hopTime=intVal;
			p_elem->curChannellNum=intVal;
			p_elem->maxDwellTime=intVal;
			p_elem->curDwellTime=intVal;
			p_elem->curSet=intVal;
			p_elem->curPattern=intVal;
			p_elem->curIndex=intVal;
			if(dot11PhyFHSSTable==NULL)
				dot11PhyFHSSTable=p_elem;
			else
				tail->next=p_elem;
			tail=p_elem;
		}
		else
			break;
	}
    static oid      dot11PhyFHSSTable_oid[] = { 1, 2, 840, 10036, 4, 4 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /*
     * create the table structure itself 
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
     */
    my_handler = netsnmp_create_handler_registration("dot11PhyFHSSTable",
                                                     dot11PhyFHSSTable_handler,
                                                     dot11PhyFHSSTable_oid,
                                                     OID_LENGTH
                                                     (dot11PhyFHSSTable_oid),
                                                     HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: ifIndex */
                                     0);

    table_info->min_column = 1;
    table_info->max_column = 7;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point = dot11PhyFHSSTable_get_first_data_point;
    iinfo->get_next_data_point = dot11PhyFHSSTable_get_next_data_point;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_dot11PhyFHSSTable",
                "Registering table dot11PhyFHSSTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}
netsnmp_variable_list *
dot11PhyFHSSTable_get_first_data_point(void **my_loop_context,
                                       void **my_data_context,
                                       netsnmp_variable_list *
                                       put_index_data,
                                       netsnmp_iterator_info *mydata)
{
	dot11PhyFHSSTable_elem *p_elem;
	p_elem=dot11PhyFHSSTable;
	if(!p_elem)
		return NULL;

	*my_loop_context = p_elem ;
	*my_data_context = p_elem ;

	netsnmp_variable_list *vptr;
	vptr = put_index_data;
	snmp_set_var_value(vptr, (u_char *) &p_elem->ifIndex,sizeof(MYIfIndex));

	return put_index_data;
}

netsnmp_variable_list *
dot11PhyFHSSTable_get_next_data_point(void **my_loop_context,
                                      void **my_data_context,
                                      netsnmp_variable_list *
                                      put_index_data,
                                      netsnmp_iterator_info *mydata)
{
	dot11PhyFHSSTable_elem *p_elem;
	p_elem=(dot11PhyFHSSTable_elem*)*my_loop_context;
	p_elem=p_elem->next;
	if(!p_elem)
		return NULL;

	*my_loop_context = p_elem ;
	*my_data_context = p_elem ;

	netsnmp_variable_list *vptr;
	vptr = put_index_data;
	snmp_set_var_value(vptr, (u_char *) &p_elem->ifIndex,sizeof(MYIfIndex));

	return put_index_data;
}

/** handles requests for the dot11PhyFHSSTable table, if anything else needs to be done */
int
dot11PhyFHSSTable_handler(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{

	dot11PhyFHSSTable_elem *p_elem;
    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
	MYINTEGER range_min,range_max;
	int rst;
    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed. 
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the dot11PhyFHSSTable table in question 
         */

        p_elem= (dot11PhyFHSSTable_elem *)netsnmp_extract_iterator_context(request);
        if (p_elem == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            
        }

        /*
         * extracts the information about the table from the request 
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested 
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request 
         */
        if (table_info == NULL) {
            continue;
        }
	switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here 
             */
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_DOT11HOPTIME:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *)& p_elem->hopTime
                                         , sizeof(MYINTEGER) );
                break;

            case COLUMN_DOT11CURRENTCHANNELNUMBER:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *)&p_elem->curChannellNum
                                         , sizeof(MYINTEGER) );
                break;

            case COLUMN_DOT11MAXDWELLTIME:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &p_elem->maxDwellTime
                                         , sizeof(MYINTEGER));
                break;

            case COLUMN_DOT11CURRENTDWELLTIME:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &p_elem->curDwellTime
                                         , sizeof(MYINTEGER));
                break;

            case COLUMN_DOT11CURRENTSET:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &p_elem->curSet
                                         , sizeof(MYINTEGER));
                break;

            case COLUMN_DOT11CURRENTPATTERN:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &p_elem->curPattern
                                         ,sizeof(MYINTEGER) );
                break;

            case COLUMN_DOT11CURRENTINDEX:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &p_elem->curIndex
                                         , sizeof(MYINTEGER) );
                break;

            default:
                /*
                 * We shouldn't get here 
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in dot11PhyFHSSTable_handler: unknown column\n");
            }
            break;
        case MODE_SET_RESERVE1:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11CURRENTCHANNELNUMBER:
			range_min=0;
			range_max=99;
			break;
		case COLUMN_DOT11CURRENTDWELLTIME:
			range_min=1;
			range_max=65535;
			break;
		case COLUMN_DOT11CURRENTSET:
			range_min=1;
			range_max=255;
			break;
		case COLUMN_DOT11CURRENTPATTERN:
			range_min=0;
			range_max=255;
			break;
		case COLUMN_DOT11CURRENTINDEX:
			range_min=1;
			range_max=255;
			break;
		default:
			netsnmp_set_request_error(reqinfo, request,SNMP_ERR_READONLY);
			return SNMP_ERR_NOERROR;
			break;
		}
		if(var->type!=ASN_INTEGER)
			netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGTYPE);
		else if(var->val_len!=sizeof(MYINTEGER))
			netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGLENGTH);
		else if( *var->val.integer<range_min || *var->val.integer>range_max)
			netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGVALUE);
		else
			;
        	break;
	case MODE_SET_RESERVE2:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11CURRENTCHANNELNUMBER:
			rst=backup(&p_elem->curChannellNum,sizeof(MYINTEGER));
			break;
		case COLUMN_DOT11CURRENTDWELLTIME:
			rst=backup(&p_elem->curDwellTime,sizeof(MYINTEGER));
			break;
		case COLUMN_DOT11CURRENTSET:
			rst=backup(&p_elem->curSet,sizeof(MYINTEGER));
			break;
		case COLUMN_DOT11CURRENTPATTERN:
			rst=backup(&p_elem->curPattern,sizeof(MYINTEGER));
			break;
		case COLUMN_DOT11CURRENTINDEX:
			rst=backup(&p_elem->curIndex,sizeof(MYINTEGER));
			break;
		default:
			break;
		}
		if(rst)
			netsnmp_set_request_error(reqinfo, request,SNMP_ERR_GENERR);
		break;
	case MODE_SET_FREE:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11CURRENTCHANNELNUMBER:
		case COLUMN_DOT11CURRENTDWELLTIME:
		case COLUMN_DOT11CURRENTSET:
		case COLUMN_DOT11CURRENTPATTERN:
		case COLUMN_DOT11CURRENTINDEX:
			clear();
			break;
		default:
			break;
		}
		break;
	case MODE_SET_ACTION:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11CURRENTCHANNELNUMBER:
			p_elem->curChannellNum=*var->val.integer;
			break;
		case COLUMN_DOT11CURRENTDWELLTIME:
			p_elem->curDwellTime=*var->val.integer;
			break;
		case COLUMN_DOT11CURRENTSET:
			p_elem->curSet=*var->val.integer;
			break;
		case COLUMN_DOT11CURRENTPATTERN:
			p_elem->curPattern=*var->val.integer;
			break;
		case COLUMN_DOT11CURRENTINDEX:
			p_elem->curIndex=*var->val.integer;
			break;
		default:
			break;
		}
		break;
	case MODE_SET_COMMIT:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11CURRENTCHANNELNUMBER:
		case COLUMN_DOT11CURRENTDWELLTIME:
		case COLUMN_DOT11CURRENTSET:
		case COLUMN_DOT11CURRENTPATTERN:
		case COLUMN_DOT11CURRENTINDEX:
			clear();
			break;
		default:
			break;
		}
		break;
	case MODE_SET_UNDO:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11CURRENTCHANNELNUMBER:
			rst=restore(&p_elem->curChannellNum,sizeof(MYINTEGER));
			break;
		case COLUMN_DOT11CURRENTDWELLTIME:
			rst=restore(&p_elem->curDwellTime,sizeof(MYINTEGER));
			break;
		case COLUMN_DOT11CURRENTSET:
			rst=restore(&p_elem->curSet,sizeof(MYINTEGER));
			break;
		case COLUMN_DOT11CURRENTPATTERN:
			rst=restore(&p_elem->curPattern,sizeof(MYINTEGER));
			break;
		case COLUMN_DOT11CURRENTINDEX:
			rst=restore(&p_elem->curIndex,sizeof(MYINTEGER));
			break;
		default:
			break;
		}
		if(rst)
			netsnmp_set_request_error(reqinfo, request,SNMP_ERR_GENERR);
		break;
        default:
            snmp_log(LOG_ERR,
                     "problem encountered in dot11PhyFHSSTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}
#endif

typedef struct dot11PhyDSSSTable_elem_s{
	MYIfIndex		ifIndex;
	struct dot11PhyDSSSTable_elem_s *next;
	//MYINTEGER	curChannel;
	MYINTEGER	CCAModeSup;
	MYEnumVal	curCCAMode;
	MYInteger32	EDThreshold;
}dot11PhyDSSSTable_elem;

static dot11PhyDSSSTable_elem *dot11PhyDSSSTable;

void
initialize_table_dot11PhyDSSSTable(void)
{
	int i;
	int intVal;
	IfList_elem* ifList;
	dot11PhyDSSSTable_elem *p_elem, *tail;
	for(ifList=g_ifList, i=0,dot11PhyDSSSTable=NULL; ifList; ifList=ifList->next, ++i)
	{
		intVal=i+1;
		p_elem=(dot11PhyDSSSTable_elem*)malloc(sizeof(dot11PhyDSSSTable_elem));
		if(p_elem)
		{
			p_elem->ifIndex=ifList->index;
			p_elem->next=NULL;
			//p_elem->curChannel=intVal;	dynamic
			p_elem->CCAModeSup=1;
			p_elem->curCCAMode=1;
			p_elem->EDThreshold=0x44;
			if(dot11PhyDSSSTable==NULL)
				dot11PhyDSSSTable=p_elem;
			else
				tail->next=p_elem;
			tail=p_elem;
		}
		else
			break;
	}
    static oid      dot11PhyDSSSTable_oid[] = { 1, 2, 840, 10036, 4, 5 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /*
     * create the table structure itself 
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
     */
    my_handler = netsnmp_create_handler_registration("dot11PhyDSSSTable",
                                                     dot11PhyDSSSTable_handler,
                                                     dot11PhyDSSSTable_oid,
                                                     OID_LENGTH
                                                     (dot11PhyDSSSTable_oid),
                                                     HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: ifIndex */
                                     0);

    table_info->min_column = 1;
    table_info->max_column = 4;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point = dot11PhyDSSSTable_get_first_data_point;
    iinfo->get_next_data_point = dot11PhyDSSSTable_get_next_data_point;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_dot11PhyDSSSTable",
                "Registering table dot11PhyDSSSTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}

netsnmp_variable_list *
dot11PhyDSSSTable_get_first_data_point(void **my_loop_context,
                                       void **my_data_context,
                                       netsnmp_variable_list *
                                       put_index_data,
                                       netsnmp_iterator_info *mydata)
{
	dot11PhyDSSSTable_elem *p_elem;
	p_elem=dot11PhyDSSSTable;
	if(!p_elem)
		return NULL;

	*my_loop_context = p_elem ;
	*my_data_context = p_elem ;

	netsnmp_variable_list *vptr;
	vptr = put_index_data;

	snmp_set_var_value(vptr, (u_char *) &p_elem->ifIndex,sizeof(MYIfIndex));

	return put_index_data;
}


netsnmp_variable_list *
dot11PhyDSSSTable_get_next_data_point(void **my_loop_context,
                                      void **my_data_context,
                                      netsnmp_variable_list *
                                      put_index_data,
                                      netsnmp_iterator_info *mydata)
{
	dot11PhyDSSSTable_elem *p_elem;
	p_elem=(dot11PhyDSSSTable_elem*)*my_loop_context;
	p_elem=p_elem->next;
	if(!p_elem)
		return NULL;

	*my_loop_context = p_elem ;
	*my_data_context = p_elem ;

	netsnmp_variable_list *vptr;
	vptr = put_index_data;

	snmp_set_var_value(vptr, (u_char *) &p_elem->ifIndex,sizeof(MYIfIndex));

	return put_index_data;
}

/** handles requests for the dot11PhyDSSSTable table, if anything else needs to be done */
int
dot11PhyDSSSTable_handler(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
	dot11PhyDSSSTable_elem *p_elem;
    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
	FILE *fp;
	MYINTEGER curChannel;
	char c;
	char command[50];

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed. 
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the dot11PhyDSSSTable table in question 
         */

        p_elem= (dot11PhyDSSSTable_elem *)netsnmp_extract_iterator_context(request);
        if (p_elem == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
          
        }

        /*
         * extracts the information about the table from the request 
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested 
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request 
         */
        if (table_info == NULL) {
            continue;
        }

	switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here 
             */

        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_DOT11CURRENTCHANNEL:
		system("/usr/bin/get_network_type> tmp/data");
		fp=fopen("/tmp/data","r");
		if(fp)
		{
			c=fgetc(fp);
			fclose(fp);
			if(c=='0')
			{
				//system("/usr/bin/get_status_channel > /tmp/data");
				curChannel=0;
			}
			else
			{
				system("/usr/bin/get_channel_select >/tmp/data");
				fp=fopen("/tmp/data","r");
				if(fp)
				{
					c=fgetc(fp);
					fclose(fp);
					if(c=='1')
						system("/usr/bin/get_status_channel > /tmp/data");
					else
						system("/usr/bin/get_channel > /tmp/data");
				}
				fp=fopen("/tmp/data","r");
				if(fp)
                		{
                        		fscanf(fp,"%d",&curChannel);
                        		fclose(fp);
                		}
			}
		}
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *)&curChannel , sizeof(MYINTEGER));
                break;

            case COLUMN_DOT11CCAMODESUPPORTED:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &p_elem->CCAModeSup
                                         , sizeof(MYINTEGER) );
                break;

            case COLUMN_DOT11CURRENTCCAMODE:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char*)&p_elem->curCCAMode
                                         ,sizeof(MYEnumVal));
                break;

            case COLUMN_DOT11EDTHRESHOLD:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &p_elem->EDThreshold
                                         , sizeof(MYInteger32) );
                break;

            default:
                /*
                 * We shouldn't get here 
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in dot11PhyDSSSTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11CURRENTCHANNEL:
			if(var->type!=ASN_INTEGER)
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGTYPE);
			else if(var->val_len!=sizeof(MYINTEGER))
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGLENGTH);
			else if(*var->val.integer<1 || *var->val.integer>14)
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGVALUE);
			else
				;
			break;
			/*
		case COLUMN_DOT11CURRENTCCAMODE:
			if(var->type!=ASN_INTEGER)
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGTYPE);
			else if(var->val_len!=sizeof(MYEnumVal))
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGLENGTH);
			else if(*var->val.integer!=1 && *var->val.integer!=2 && *var->val.integer!=4)
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGVALUE);
			else
				;
			break;
		case COLUMN_DOT11EDTHRESHOLD:
			if(var->type!=ASN_INTEGER)
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGTYPE);
			else if(var->val_len!=sizeof(MYInteger32))
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGLENGTH);
			else
				;
			break;
			*/
		default:
			netsnmp_set_request_error(reqinfo, request,SNMP_ERR_READONLY);
			break;
		}
        	break;
	case MODE_SET_RESERVE2:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11CURRENTCHANNEL:
			break;		
		case COLUMN_DOT11CURRENTCCAMODE:
			break;
		case COLUMN_DOT11EDTHRESHOLD:
			break;
		default:
			break;
		}
		break;
	case MODE_SET_FREE:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11CURRENTCHANNEL:
		case COLUMN_DOT11CURRENTCCAMODE:
		case COLUMN_DOT11EDTHRESHOLD:
			break;
		default:
			break;
		}
		break;
	case MODE_SET_ACTION:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11CURRENTCHANNEL:
			system("/usr/bin/get_network_type > /tmp/data");
			fp=fopen("/tmp/data","r");
			if(fp)
			{
				c=fgetc(fp);
				fclose(fp);
				if(c == '0')
					break;
			}
			system("/usr/bin/cfgset --network_mode 1");
			system("/usr/bin/cfgset --channel_select 0");
			sprintf(command,"/usr/bin/cfgset --channel %d",*var->val.integer);
			system(command);
			break;
			/*
		case COLUMN_DOT11CURRENTCCAMODE:
			break;
		case COLUMN_DOT11EDTHRESHOLD:
			break;
			*/
		default:
			break;
		}
		break;
	case MODE_SET_COMMIT:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11CURRENTCHANNEL:
		//case COLUMN_DOT11CURRENTCCAMODE:
		//case COLUMN_DOT11EDTHRESHOLD:
			//clear();
			break;
		default:
			break;
		}
		break;
	case MODE_SET_UNDO:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11CURRENTCHANNEL:
			break;
			/*
		case COLUMN_DOT11CURRENTCCAMODE:
			break;
		case COLUMN_DOT11EDTHRESHOLD:
			break;
			*/
		default:
			break;
		}
		break;
        default:
            snmp_log(LOG_ERR,
                     "problem encountered in dot11PhyDSSSTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}

#if 0
typedef struct dot11PhyIRTable_elem_s{
	MYIfIndex		ifIndex;
	struct dot11PhyIRTable_elem_s *next;
	MYInteger32	CCAWatchdogTimerMax;
	MYInteger32	CCAWatchdogCountMax;
	MYInteger32	CCAWatchdogTimerMin;
	MYInteger32	CCAWatchdogCountMin;
}dot11PhyIRTable_elem;

static dot11PhyIRTable_elem *dot11PhyIRTable;

void
initialize_table_dot11PhyIRTable(void)
{
	int i;
	IfList_elem* ifList;
	dot11PhyIRTable_elem *p_elem, *tail;
	for(ifList=g_ifList, i=0,dot11PhyIRTable=NULL; ifList; ifList=ifList->next, ++i)
	{
		p_elem=(dot11PhyIRTable_elem*)malloc(sizeof(dot11PhyIRTable_elem));
		if(p_elem)
		{
			p_elem->ifIndex=ifList->index;
			p_elem->next=NULL;
			p_elem->CCAWatchdogTimerMax=i+1;
			p_elem->CCAWatchdogCountMax=i+1;
			p_elem->CCAWatchdogTimerMin=i+1;
			p_elem->CCAWatchdogCountMin=i+1;
			if(dot11PhyIRTable==NULL)
				dot11PhyIRTable=p_elem;
			else
				tail->next=p_elem;
			tail=p_elem;
		}
		else
			break;
	}
    static oid      dot11PhyIRTable_oid[] = { 1, 2, 840, 10036, 4, 6 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /*
     * create the table structure itself 
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
     */
    my_handler = netsnmp_create_handler_registration("dot11PhyIRTable",
                                                     dot11PhyIRTable_handler,
                                                     dot11PhyIRTable_oid,
                                                     OID_LENGTH
                                                     (dot11PhyIRTable_oid),
                                                     HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: ifIndex */
                                     0);

    table_info->min_column = 1;
    table_info->max_column = 4;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point = dot11PhyIRTable_get_first_data_point;
    iinfo->get_next_data_point = dot11PhyIRTable_get_next_data_point;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_dot11PhyIRTable",
                "Registering table dot11PhyIRTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}


netsnmp_variable_list *
dot11PhyIRTable_get_first_data_point(void **my_loop_context,
                                     void **my_data_context,
                                     netsnmp_variable_list *
                                     put_index_data,
                                     netsnmp_iterator_info *mydata)
{
	dot11PhyIRTable_elem *p_elem;
	p_elem=dot11PhyIRTable;
	if(!p_elem)
		return NULL;

	*my_loop_context = p_elem ;
	*my_data_context = p_elem ;

	netsnmp_variable_list *vptr;
	vptr = put_index_data;

	snmp_set_var_value(vptr, (u_char *) &p_elem->ifIndex,sizeof(MYIfIndex));

	return put_index_data;
}



netsnmp_variable_list *
dot11PhyIRTable_get_next_data_point(void **my_loop_context,
                                    void **my_data_context,
                                    netsnmp_variable_list * put_index_data,
                                    netsnmp_iterator_info *mydata)
{
	dot11PhyIRTable_elem *p_elem;
	p_elem=(dot11PhyIRTable_elem*)*my_loop_context;
	p_elem=p_elem->next;
	if(!p_elem)
		return NULL;

	*my_loop_context = p_elem ;
	*my_data_context = p_elem ;

	netsnmp_variable_list *vptr;
	vptr = put_index_data;

	snmp_set_var_value(vptr, (u_char *) &p_elem->ifIndex,sizeof(MYIfIndex));

	return put_index_data;
}

/** handles requests for the dot11PhyIRTable table, if anything else needs to be done */
int
dot11PhyIRTable_handler(netsnmp_mib_handler *handler,
                        netsnmp_handler_registration *reginfo,
                        netsnmp_agent_request_info *reqinfo,
                        netsnmp_request_info *requests)
{
	dot11PhyIRTable_elem *p_elem;
	int rst;
    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed. 
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the dot11PhyIRTable table in question 
         */
 
        p_elem= (dot11PhyIRTable_elem  *)netsnmp_extract_iterator_context(request);
        if (p_elem == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            
        }

        /*
         * extracts the information about the table from the request 
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested 
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request 
         */
        if (table_info == NULL) {
            continue;
        }
        switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here 
             */
             
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_DOT11CCAWATCHDOGTIMERMAX:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &p_elem->CCAWatchdogTimerMax
                                         , sizeof(MYInteger32) );
                break;

            case COLUMN_DOT11CCAWATCHDOGCOUNTMAX:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &p_elem->CCAWatchdogCountMax
                                         , sizeof(MYInteger32) );
                break;

            case COLUMN_DOT11CCAWATCHDOGTIMERMIN:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &p_elem->CCAWatchdogTimerMin
                                         , sizeof(MYInteger32) );
                break;

            case COLUMN_DOT11CCAWATCHDOGCOUNTMIN:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &p_elem->CCAWatchdogCountMin
                                         , sizeof(MYInteger32));
                break;

            default:
                /*
                 * We shouldn't get here 
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in dot11PhyIRTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11CCAWATCHDOGTIMERMAX:
		case COLUMN_DOT11CCAWATCHDOGCOUNTMAX:
		case COLUMN_DOT11CCAWATCHDOGTIMERMIN:
		case COLUMN_DOT11CCAWATCHDOGCOUNTMIN:
			if(var->type!=ASN_INTEGER)
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGTYPE);
			else if(var->val_len!=sizeof(MYInteger32))
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGLENGTH);
			else
				;
			break;
		default:
			netsnmp_set_request_error(reqinfo, request,SNMP_ERR_READONLY);
			break;
		}
        	break;
	case MODE_SET_RESERVE2:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11CCAWATCHDOGTIMERMAX:
			rst=backup(&p_elem->CCAWatchdogTimerMax,sizeof(MYInteger32));
			break;
		case COLUMN_DOT11CCAWATCHDOGCOUNTMAX:
			rst=backup(&p_elem->CCAWatchdogCountMax,sizeof(MYInteger32));
			break;
		case COLUMN_DOT11CCAWATCHDOGTIMERMIN:
			rst=backup(&p_elem->CCAWatchdogTimerMin,sizeof(MYInteger32));
			break;
		case COLUMN_DOT11CCAWATCHDOGCOUNTMIN:
			rst=backup(&p_elem->CCAWatchdogCountMin,sizeof(MYInteger32));
			break;
		default:
			break;
		}
		if(rst)
			netsnmp_set_request_error(reqinfo, request,SNMP_ERR_GENERR);
		break;
	case MODE_SET_FREE:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11CCAWATCHDOGTIMERMAX:
		case COLUMN_DOT11CCAWATCHDOGCOUNTMAX:
		case COLUMN_DOT11CCAWATCHDOGTIMERMIN:
		case COLUMN_DOT11CCAWATCHDOGCOUNTMIN:
			clear();
			break;
		default:
			break;
		}
		break;
	case MODE_SET_ACTION:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11CCAWATCHDOGTIMERMAX:
			p_elem->CCAWatchdogTimerMax=*var->val.integer;
			break;
		case COLUMN_DOT11CCAWATCHDOGCOUNTMAX:
			p_elem->CCAWatchdogCountMax=*var->val.integer;
			break;
		case COLUMN_DOT11CCAWATCHDOGTIMERMIN:
			p_elem->CCAWatchdogTimerMin=*var->val.integer;
			break;
		case COLUMN_DOT11CCAWATCHDOGCOUNTMIN:
			p_elem->CCAWatchdogCountMin=*var->val.integer;
			break;
		default:
			break;
		}
		break;
	case MODE_SET_COMMIT:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11CCAWATCHDOGTIMERMAX:
		case COLUMN_DOT11CCAWATCHDOGCOUNTMAX:
		case COLUMN_DOT11CCAWATCHDOGTIMERMIN:
		case COLUMN_DOT11CCAWATCHDOGCOUNTMIN:
			clear();
			break;
		default:
			break;
		}
		break;
	case MODE_SET_UNDO:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11CCAWATCHDOGTIMERMAX:
			rst=restore(&p_elem->CCAWatchdogTimerMax,sizeof(MYInteger32));
			break;
		case COLUMN_DOT11CCAWATCHDOGCOUNTMAX:
			rst=restore(&p_elem->CCAWatchdogCountMax,sizeof(MYInteger32));
			break;
		case COLUMN_DOT11CCAWATCHDOGTIMERMIN:
			rst=restore(&p_elem->CCAWatchdogTimerMin,sizeof(MYInteger32));
			break;
		case COLUMN_DOT11CCAWATCHDOGCOUNTMIN:
			rst=restore(&p_elem->CCAWatchdogCountMin,sizeof(MYInteger32));
			break;
		default:
			break;
		}
		if(rst)
			netsnmp_set_request_error(reqinfo, request,SNMP_ERR_GENERR);
		break;
        default:
            snmp_log(LOG_ERR,
                     "problem encountered in dot11PhyIRTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}
#endif

typedef struct dot11RegDomainsSupportedTable_elem_s{
	MYIfIndex		ifIndex;
	MYInteger32	regDomainsSupportIndex;
	struct dot11RegDomainsSupportedTable_elem_s *next;
	MYEnumVal	regDomainsSupportValue;
}dot11RegDomainsSupportedTable_elem;

static dot11RegDomainsSupportedTable_elem *dot11RegDomainsSupportedTable;


void
initialize_table_dot11RegDomainsSupportedTable(void)
{
	int i,j;
	IfList_elem* ifList;
	dot11RegDomainsSupportedTable_elem *p_elem, *tail;
	for(ifList=g_ifList, i=0,dot11RegDomainsSupportedTable=NULL; ifList; ifList=ifList->next, ++i)
	{
		for(j=0;j<DOT11REGDOMAINSSUPPORTEDTABLE_INDEX_MAX;++j)
		{
			p_elem=(dot11RegDomainsSupportedTable_elem*)malloc(sizeof(dot11RegDomainsSupportedTable_elem));
			if(p_elem)
			{
				p_elem->ifIndex=ifList->index;
				p_elem->regDomainsSupportIndex=j+1;
				p_elem->next=NULL;
				p_elem->regDomainsSupportValue=16*(4-j);
				if(dot11RegDomainsSupportedTable==NULL)
					dot11RegDomainsSupportedTable=p_elem;
				else
					tail->next=p_elem;
				tail=p_elem;
			}
			else
			{
				ifList=NULL;
				break;
			}
			
		}
	}
    static oid      dot11RegDomainsSupportedTable_oid[] =
        { 1, 2, 840, 10036, 4, 7 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /*
     * create the table structure itself 
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
     */
    my_handler =
        netsnmp_create_handler_registration
        ("dot11RegDomainsSupportedTable",
         dot11RegDomainsSupportedTable_handler,
         dot11RegDomainsSupportedTable_oid,
         OID_LENGTH(dot11RegDomainsSupportedTable_oid),
         HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: ifIndex */
                                     ASN_INTEGER,       /* index: dot11RegDomainsSupportIndex */
                                     0);

    table_info->min_column = 2;
    table_info->max_column = 2;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point =
        dot11RegDomainsSupportedTable_get_first_data_point;
    iinfo->get_next_data_point =
        dot11RegDomainsSupportedTable_get_next_data_point;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_dot11RegDomainsSupportedTable",
                "Registering table dot11RegDomainsSupportedTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}


netsnmp_variable_list *
dot11RegDomainsSupportedTable_get_first_data_point(void **my_loop_context,
                                                   void **my_data_context,
                                                   netsnmp_variable_list *
                                                   put_index_data,
                                                   netsnmp_iterator_info
                                                   *mydata)
{
	dot11RegDomainsSupportedTable_elem *p_elem;
	p_elem=dot11RegDomainsSupportedTable;
	if(!p_elem)
		return NULL;

	*my_loop_context = p_elem ;
	*my_data_context = p_elem ;

	netsnmp_variable_list *vptr;
	vptr = put_index_data;

	snmp_set_var_value(vptr, (u_char *) &p_elem->ifIndex,sizeof(MYIfIndex));
	vptr = vptr->next_variable;
	snmp_set_var_value(vptr,(u_char*)&p_elem->regDomainsSupportIndex,sizeof(MYInteger32));

	return put_index_data;
}

/** functionally the same as dot11RegDomainsSupportedTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it and the return
   my_loop_context->next.  The my_data_context pointer should be set
   to something you need later and the indexes in put_index_data
   updated again. */

netsnmp_variable_list *
dot11RegDomainsSupportedTable_get_next_data_point(void **my_loop_context,
                                                  void **my_data_context,
                                                  netsnmp_variable_list *
                                                  put_index_data,
                                                  netsnmp_iterator_info
                                                  *mydata)
{
	dot11RegDomainsSupportedTable_elem *p_elem;
	p_elem=(dot11RegDomainsSupportedTable_elem*)*my_loop_context;
	p_elem=p_elem->next;
	if(!p_elem)
		return NULL;

	*my_loop_context = p_elem ;
	*my_data_context = p_elem ;

	netsnmp_variable_list *vptr;
	vptr = put_index_data;

	snmp_set_var_value(vptr, (u_char *) &p_elem->ifIndex,sizeof(MYIfIndex));
	vptr = vptr->next_variable;
	snmp_set_var_value(vptr,(u_char*)&p_elem->regDomainsSupportIndex,sizeof(MYInteger32));

	return put_index_data;
}

/** handles requests for the dot11RegDomainsSupportedTable table, if anything else needs to be done */
int
dot11RegDomainsSupportedTable_handler(netsnmp_mib_handler *handler,
                                      netsnmp_handler_registration
                                      *reginfo,
                                      netsnmp_agent_request_info *reqinfo,
                                      netsnmp_request_info *requests)
{
	dot11RegDomainsSupportedTable_elem *p_elem;
    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed. 
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the dot11RegDomainsSupportedTable table in question 
         */
 
        p_elem = (dot11RegDomainsSupportedTable_elem*)netsnmp_extract_iterator_context(request);
        if (p_elem == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }    
           
        }
	
        /*
         * extracts the information about the table from the request 
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested 
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request 
         */
        if (table_info == NULL) {
            continue;
        }
        switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here 
             */
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_DOT11REGDOMAINSSUPPORTVALUE:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *)&p_elem->regDomainsSupportValue
                                         , sizeof(MYEnumVal) );
                break;

            default:
                /*
                 * We shouldn't get here 
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in dot11RegDomainsSupportedTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
		netsnmp_set_request_error(reqinfo, request,SNMP_ERR_READONLY);
        	break;
	case MODE_SET_FREE:
		break;
        default:
            snmp_log(LOG_ERR,
                     "problem encountered in dot11RegDomainsSupportedTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}


typedef struct dot11AntennasListTable_elem_s{
	MYIfIndex		ifIndex;
	MYInteger32	antennaListIndex;
	struct dot11AntennasListTable_elem_s *next;
	MYEnumVal	supportedTxAntenna;
	MYEnumVal	supportedRxAntenna;
	MYEnumVal	diversitySelectionRx;
}dot11AntennasListTable_elem;

static dot11AntennasListTable_elem *dot11AntennasListTable;

void
initialize_table_dot11AntennasListTable(void)
{
	int i,j;
	IfList_elem* ifList;
	dot11AntennasListTable_elem *p_elem, *tail;
	for(ifList=g_ifList, i=0,dot11AntennasListTable=NULL; ifList; ifList=ifList->next, ++i)
	{
		for(j=0;j<DOT11ANTENNASLISTTABLE_INDEX_MAX;++j)
		{
			p_elem=(dot11AntennasListTable_elem*)malloc(sizeof(dot11AntennasListTable_elem));
			if(p_elem)
			{
				p_elem->ifIndex=ifList->index;
				p_elem->antennaListIndex=j+1;
				p_elem->next=NULL;
				p_elem->supportedTxAntenna=1;
				p_elem->supportedRxAntenna=1;
				p_elem->diversitySelectionRx=1;
				if(dot11AntennasListTable==NULL)
					dot11AntennasListTable=p_elem;
				else
					tail->next=p_elem;
				tail=p_elem;
			}
			else
			{
				ifList=NULL;
				break;
			}
		}
	}
    static oid      dot11AntennasListTable_oid[] =
        { 1, 2, 840, 10036, 4, 8 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /*
     * create the table structure itself 
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
     */
    my_handler =
        netsnmp_create_handler_registration("dot11AntennasListTable",
                                            dot11AntennasListTable_handler,
                                            dot11AntennasListTable_oid,
                                            OID_LENGTH
                                            (dot11AntennasListTable_oid),
                                            HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: ifIndex */
                                     ASN_INTEGER,       /* index: dot11AntennaListIndex */
                                     0);

    table_info->min_column = 2;
    table_info->max_column = 4;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point =
        dot11AntennasListTable_get_first_data_point;
    iinfo->get_next_data_point =
        dot11AntennasListTable_get_next_data_point;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_dot11AntennasListTable",
                "Registering table dot11AntennasListTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}


netsnmp_variable_list *
dot11AntennasListTable_get_first_data_point(void **my_loop_context,
                                            void **my_data_context,
                                            netsnmp_variable_list *
                                            put_index_data,
                                            netsnmp_iterator_info *mydata)
{
	dot11AntennasListTable_elem *p_elem;
	p_elem=dot11AntennasListTable;
	if(!p_elem)
		return NULL;

	*my_loop_context = p_elem;
	*my_data_context = p_elem ;

	netsnmp_variable_list *vptr;
	vptr = put_index_data;

	snmp_set_var_value(vptr, (u_char *) &p_elem->ifIndex,sizeof(MYIfIndex));
	vptr = vptr->next_variable;
	snmp_set_var_value(vptr,(u_char *) &p_elem->antennaListIndex,sizeof(MYInteger32));
                      
	return put_index_data;
}


netsnmp_variable_list *
dot11AntennasListTable_get_next_data_point(void **my_loop_context,
                                           void **my_data_context,
                                           netsnmp_variable_list *
                                           put_index_data,
                                           netsnmp_iterator_info *mydata)
{
	dot11AntennasListTable_elem *p_elem;
	p_elem=(dot11AntennasListTable_elem*)*my_loop_context;
	p_elem=p_elem->next;
	if(!p_elem)
		return NULL;

	*my_loop_context = p_elem;
	*my_data_context = p_elem ;

	netsnmp_variable_list *vptr;
	vptr = put_index_data;

	snmp_set_var_value(vptr, (u_char *) &p_elem->ifIndex,sizeof(MYIfIndex));
	vptr = vptr->next_variable;
	snmp_set_var_value(vptr,(u_char *) &p_elem->antennaListIndex,sizeof(MYInteger32));
                      
	return put_index_data;
}

/** handles requests for the dot11AntennasListTable table, if anything else needs to be done */
int
dot11AntennasListTable_handler(netsnmp_mib_handler *handler,
                               netsnmp_handler_registration *reginfo,
                               netsnmp_agent_request_info *reqinfo,
                               netsnmp_request_info *requests)
{
	dot11AntennasListTable_elem *p_elem;
	int rst;
    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed. 
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the dot11AntennasListTable table in question 
         */

        p_elem= (dot11AntennasListTable_elem *)netsnmp_extract_iterator_context(request);
        if (p_elem == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            
        }
	
        /*
         * extracts the information about the table from the request 
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested 
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request 
         */
        if (table_info == NULL) {
            continue;
        }

        switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here 
             */

        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_DOT11SUPPORTEDTXANTENNA:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &p_elem->supportedTxAntenna
                                         , sizeof(MYEnumVal) );
                break;

            case COLUMN_DOT11SUPPORTEDRXANTENNA:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &p_elem->supportedRxAntenna
                                         , sizeof(MYEnumVal) );
                break;

            case COLUMN_DOT11DIVERSITYSELECTIONRX:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &p_elem->diversitySelectionRx
                                         , sizeof(MYEnumVal));
                break;

            default:
                /*
                 * We shouldn't get here 
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in dot11AntennasListTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11SUPPORTEDTXANTENNA:
		case COLUMN_DOT11SUPPORTEDRXANTENNA:
		case COLUMN_DOT11DIVERSITYSELECTIONRX:
			if(var->type!=ASN_INTEGER)
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGTYPE);
			else if(var->val_len!=sizeof(MYEnumVal))
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGLENGTH);
			else if(*var->val.integer!=1 && *var->val.integer!=2)
				netsnmp_set_request_error(reqinfo, request,SNMP_ERR_WRONGVALUE);
			else
				;
			break;
		default:
			netsnmp_set_request_error(reqinfo, request,SNMP_ERR_READONLY);
			break;
		}
        	break;
	case MODE_SET_RESERVE2:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11SUPPORTEDTXANTENNA:
			//rst=backup(&p_elem->supportedTxAntenna,sizeof(MYEnumVal));
			break;
		case COLUMN_DOT11SUPPORTEDRXANTENNA:
			//rst=backup(&p_elem->supportedRxAntenna,sizeof(MYEnumVal));
			break;
		case COLUMN_DOT11DIVERSITYSELECTIONRX:
			//rst=backup(&p_elem->diversitySelectionRx,sizeof(MYEnumVal));
			break;
		default:
			break;
		}
		/*
		if(rst)
			netsnmp_set_request_error(reqinfo, request,SNMP_ERR_GENERR);
		*/
		break;
	case MODE_SET_FREE:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11SUPPORTEDTXANTENNA:
		case COLUMN_DOT11SUPPORTEDRXANTENNA:
		case COLUMN_DOT11DIVERSITYSELECTIONRX:
		//	clear();
			break;
		default:
			break;
		}
		break;
	case MODE_SET_ACTION:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11SUPPORTEDTXANTENNA:
			//p_elem->supportedTxAntenna=*var->val.integer;
			break;
		case COLUMN_DOT11SUPPORTEDRXANTENNA:
			//p_elem->supportedRxAntenna=*var->val.integer;
			break;
		case COLUMN_DOT11DIVERSITYSELECTIONRX:
			//p_elem->diversitySelectionRx=*var->val.integer;
		default:
			break;
		}

		break;
	case MODE_SET_COMMIT:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11SUPPORTEDTXANTENNA:
		case COLUMN_DOT11SUPPORTEDRXANTENNA:
		case COLUMN_DOT11DIVERSITYSELECTIONRX:
			//clear();
		default:
			break;
		}
		break;
	case MODE_SET_UNDO:
		switch (table_info->colnum) 
		{
		case COLUMN_DOT11SUPPORTEDTXANTENNA:
			//rst=restore(&p_elem->supportedTxAntenna,sizeof(MYEnumVal));
			break;
		case COLUMN_DOT11SUPPORTEDRXANTENNA:
			//rst=restore(&p_elem->supportedRxAntenna,sizeof(MYEnumVal));
			break;
		case COLUMN_DOT11DIVERSITYSELECTIONRX:
			//rst=restore(&p_elem->diversitySelectionRx,sizeof(MYEnumVal));
			break;
		default:
			break;
		}
		/*
		if(rst)
			netsnmp_set_request_error(reqinfo, request,SNMP_ERR_GENERR);
		*/
		break;
        default:
            snmp_log(LOG_ERR,
                     "problem encountered in dot11AntennasListTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}

typedef struct dot11SupportedDataRatesTxTable_elem_s{
	MYIfIndex		ifIndex;
	MYInteger32	supportedDataRatesTxIndex;
	struct dot11SupportedDataRatesTxTable_elem_s *next;
	MYInteger32	supportedDataRatesTxValue;
}dot11SupportedDataRatesTxTable_elem;

static dot11SupportedDataRatesTxTable_elem *dot11SupportedDataRatesTxTable;

void
initialize_table_dot11SupportedDataRatesTxTable(void)
{
	int i,j;
	IfList_elem* ifList;
	dot11SupportedDataRatesTxTable_elem *p_elem, *tail;
	const int value[4]={2,4,11,22};
	for(ifList=g_ifList, i=0,dot11SupportedDataRatesTxTable=NULL; ifList; ifList=ifList->next, ++i)
	{
		for(j=0;j<DOT11SUPPORTEDDATARATESTXTABLE_INDEX_MAX;++j)
		{
			p_elem=(dot11SupportedDataRatesTxTable_elem*)malloc(sizeof(dot11SupportedDataRatesTxTable_elem));
			if(p_elem)
			{
				p_elem->ifIndex=ifList->index;
				p_elem->supportedDataRatesTxIndex=j+1;
				p_elem->next=NULL;
				p_elem->supportedDataRatesTxValue=value[j];
				if(dot11SupportedDataRatesTxTable==NULL)
					dot11SupportedDataRatesTxTable=p_elem;
				else
					tail->next=p_elem;
				tail=p_elem;
			}
			else
			{
				ifList=NULL;
				break;
			}
		}
	}
    static oid      dot11SupportedDataRatesTxTable_oid[] =
        { 1, 2, 840, 10036, 4, 9 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /*
     * create the table structure itself 
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
     */
    my_handler =
        netsnmp_create_handler_registration
        ("dot11SupportedDataRatesTxTable",
         dot11SupportedDataRatesTxTable_handler,
         dot11SupportedDataRatesTxTable_oid,
         OID_LENGTH(dot11SupportedDataRatesTxTable_oid),
         HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: ifIndex */
                                     ASN_INTEGER,       /* index: dot11SupportedDataRatesTxIndex */
                                     0);

    table_info->min_column = 2;
    table_info->max_column = 2;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point =
        dot11SupportedDataRatesTxTable_get_first_data_point;
    iinfo->get_next_data_point =
        dot11SupportedDataRatesTxTable_get_next_data_point;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_dot11SupportedDataRatesTxTable",
                "Registering table dot11SupportedDataRatesTxTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}


netsnmp_variable_list *
dot11SupportedDataRatesTxTable_get_first_data_point(void **my_loop_context,
                                                    void **my_data_context,
                                                    netsnmp_variable_list *
                                                    put_index_data,
                                                    netsnmp_iterator_info
                                                    *mydata)
{
	dot11SupportedDataRatesTxTable_elem *p_elem;
	p_elem=dot11SupportedDataRatesTxTable;
	if(!p_elem)
		return NULL;
	
	*my_loop_context = p_elem;
	*my_data_context = p_elem;

	netsnmp_variable_list *vptr;
	vptr = put_index_data;

    	snmp_set_var_value(vptr, (u_char *) &p_elem->ifIndex,sizeof(MYIfIndex));
	vptr = vptr->next_variable;
	snmp_set_var_value(vptr,(u_char *) &p_elem->supportedDataRatesTxIndex,sizeof(MYInteger32));

    return put_index_data;
}


netsnmp_variable_list *
dot11SupportedDataRatesTxTable_get_next_data_point(void **my_loop_context,
                                                   void **my_data_context,
                                                   netsnmp_variable_list *
                                                   put_index_data,
                                                   netsnmp_iterator_info
                                                   *mydata)
{
	dot11SupportedDataRatesTxTable_elem *p_elem;
	p_elem=(dot11SupportedDataRatesTxTable_elem*)*my_loop_context;
	p_elem=p_elem->next;
	if(!p_elem)
		return NULL;
	
	*my_loop_context = p_elem;
	*my_data_context = p_elem;

	netsnmp_variable_list *vptr;
	vptr = put_index_data;

    	snmp_set_var_value(vptr, (u_char *) &p_elem->ifIndex,sizeof(MYIfIndex));
	vptr = vptr->next_variable;
	snmp_set_var_value(vptr,(u_char *) &p_elem->supportedDataRatesTxIndex,sizeof(MYInteger32));

    return put_index_data;
}

/** handles requests for the dot11SupportedDataRatesTxTable table, if anything else needs to be done */
int
dot11SupportedDataRatesTxTable_handler(netsnmp_mib_handler *handler,
                                       netsnmp_handler_registration
                                       *reginfo,
                                       netsnmp_agent_request_info *reqinfo,
                                       netsnmp_request_info *requests)
{
	dot11SupportedDataRatesTxTable_elem *p_elem;
    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed. 
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the dot11SupportedDataRatesTxTable table in question 
         */

       p_elem = (dot11SupportedDataRatesTxTable_elem *)netsnmp_extract_iterator_context(request);
        if (p_elem == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            
        }
	
        /*
         * extracts the information about the table from the request 
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested 
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request 
         */
        if (table_info == NULL) {
            continue;
        }

        switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here 
             */
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_DOT11SUPPORTEDDATARATESTXVALUE:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &p_elem->supportedDataRatesTxValue
                                         , sizeof(MYInteger32) );
                break;

            default:
                /*
                 * We shouldn't get here 
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in dot11SupportedDataRatesTxTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
		netsnmp_set_request_error(reqinfo, request,SNMP_ERR_READONLY);
		break;
	case MODE_SET_FREE:
		break;
        default:
            snmp_log(LOG_ERR,
                     "problem encountered in dot11SupportedDataRatesTxTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}

typedef struct dot11SupportedDataRatesRxTable_elem_s{
	MYIfIndex		ifIndex;
	MYInteger32	supportedDataRatesRxIndex;
	struct dot11SupportedDataRatesRxTable_elem_s *next;
	MYInteger32 supportedDataRatesRxValue;
}dot11SupportedDataRatesRxTable_elem;

static dot11SupportedDataRatesRxTable_elem *dot11SupportedDataRatesRxTable;

void
initialize_table_dot11SupportedDataRatesRxTable(void)
{
	int i,j;
	IfList_elem* ifList;
	dot11SupportedDataRatesRxTable_elem *p_elem, *tail;
	const int value[4]={2,4,11,22};
	for(ifList=g_ifList, i=0,dot11SupportedDataRatesRxTable=NULL; ifList; ifList=ifList->next, ++i)
	{
		for(j=0;j<DOT11SUPPORTEDDATARATESRXTABLE_INDEX_MAX;++j)
		{
			p_elem=(dot11SupportedDataRatesRxTable_elem*)malloc(sizeof(dot11SupportedDataRatesRxTable_elem));
			if(p_elem)
			{
				p_elem->ifIndex=ifList->index;
				p_elem->supportedDataRatesRxIndex=j+1;
				p_elem->next=NULL;
				p_elem->supportedDataRatesRxValue=value[j];
				if(dot11SupportedDataRatesRxTable==NULL)
					dot11SupportedDataRatesRxTable=p_elem;
				else
					tail->next=p_elem;
				tail=p_elem;
			}
			else
			{
				ifList=NULL;
				break;
			}
		}
	}
    static oid      dot11SupportedDataRatesRxTable_oid[] =
        { 1, 2, 840, 10036, 4, 10 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /*
     * create the table structure itself 
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
     */
    my_handler =
        netsnmp_create_handler_registration
        ("dot11SupportedDataRatesRxTable",
         dot11SupportedDataRatesRxTable_handler,
         dot11SupportedDataRatesRxTable_oid,
         OID_LENGTH(dot11SupportedDataRatesRxTable_oid),
         HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: ifIndex */
                                     ASN_INTEGER,       /* index: dot11SupportedDataRatesRxIndex */
                                     0);

    table_info->min_column = 2;
    table_info->max_column = 2;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point =
        dot11SupportedDataRatesRxTable_get_first_data_point;
    iinfo->get_next_data_point =
        dot11SupportedDataRatesRxTable_get_next_data_point;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_dot11SupportedDataRatesRxTable",
                "Registering table dot11SupportedDataRatesRxTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}


netsnmp_variable_list *
dot11SupportedDataRatesRxTable_get_first_data_point(void **my_loop_context,
                                                    void **my_data_context,
                                                    netsnmp_variable_list *
                                                    put_index_data,
                                                    netsnmp_iterator_info
                                                    *mydata)
{
	dot11SupportedDataRatesRxTable_elem *p_elem;
	p_elem=dot11SupportedDataRatesRxTable;
	if(!p_elem)
		return NULL;
	
	*my_loop_context = p_elem;
	*my_data_context = p_elem;

	netsnmp_variable_list *vptr;
	vptr = put_index_data;

	snmp_set_var_value(vptr, (u_char *) &p_elem->ifIndex,sizeof(MYIfIndex));
	vptr = vptr->next_variable;
	snmp_set_var_value(vptr,(u_char *)&p_elem->supportedDataRatesRxIndex,sizeof(MYInteger32));

	return put_index_data;
}


netsnmp_variable_list *
dot11SupportedDataRatesRxTable_get_next_data_point(void **my_loop_context,
                                                   void **my_data_context,
                                                   netsnmp_variable_list *
                                                   put_index_data,
                                                   netsnmp_iterator_info
                                                   *mydata)
{
	dot11SupportedDataRatesRxTable_elem *p_elem;
	p_elem=(dot11SupportedDataRatesRxTable_elem*)*my_loop_context;
	p_elem=p_elem->next;
	if(!p_elem)
		return NULL;
	
	*my_loop_context = p_elem;
	*my_data_context = p_elem;

	netsnmp_variable_list *vptr;
	vptr = put_index_data;

	snmp_set_var_value(vptr, (u_char *) &p_elem->ifIndex,sizeof(MYIfIndex));
	vptr = vptr->next_variable;
	snmp_set_var_value(vptr,(u_char *)&p_elem->supportedDataRatesRxIndex,sizeof(MYInteger32));

	return put_index_data;
}

/** handles requests for the dot11SupportedDataRatesRxTable table, if anything else needs to be done */
int
dot11SupportedDataRatesRxTable_handler(netsnmp_mib_handler *handler,
                                       netsnmp_handler_registration
                                       *reginfo,
                                       netsnmp_agent_request_info *reqinfo,
                                       netsnmp_request_info *requests)
{
	dot11SupportedDataRatesRxTable_elem *p_elem;
    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed. 
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the dot11SupportedDataRatesRxTable table in question 
         */
 
        p_elem = (dot11SupportedDataRatesRxTable_elem *)netsnmp_extract_iterator_context(request);
        if (p_elem == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            
        }
        /*
         * extracts the information about the table from the request 
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested 
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request 
         */
        if (table_info == NULL) {
            continue;
        }

        switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here 
             */
             
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_DOT11SUPPORTEDDATARATESRXVALUE:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &p_elem->supportedDataRatesRxValue
                                         , sizeof(MYInteger32) );
                break;

            default:
                /*
                 * We shouldn't get here 
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in dot11SupportedDataRatesRxTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
		netsnmp_set_request_error(reqinfo, request,SNMP_ERR_READONLY);
		break;
	case MODE_SET_FREE:
		break;
        default:
            snmp_log(LOG_ERR,
                     "problem encountered in dot11SupportedDataRatesRxTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}
